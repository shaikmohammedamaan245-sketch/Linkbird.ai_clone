"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/better-call";
exports.ids = ["vendor-chunks/better-call"];
exports.modules = {

/***/ "(rsc)/./node_modules/better-call/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/better-call/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   _statusCode: () => (/* binding */ _statusCode),\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint2),\n/* harmony export */   createInternalContext: () => (/* binding */ createInternalContext),\n/* harmony export */   createMiddleware: () => (/* binding */ createMiddleware),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   generator: () => (/* binding */ generator),\n/* harmony export */   getCookieKey: () => (/* binding */ getCookieKey),\n/* harmony export */   getHTML: () => (/* binding */ getHTML),\n/* harmony export */   hideInternalStackFrames: () => (/* binding */ hideInternalStackFrames),\n/* harmony export */   makeErrorForHideStackFrame: () => (/* binding */ makeErrorForHideStackFrame),\n/* harmony export */   parseCookies: () => (/* binding */ parseCookies),\n/* harmony export */   serializeCookie: () => (/* binding */ serializeCookie),\n/* harmony export */   serializeSignedCookie: () => (/* binding */ serializeSignedCookie),\n/* harmony export */   toResponse: () => (/* binding */ toResponse)\n/* harmony export */ });\n/* harmony import */ var uncrypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uncrypto */ \"(rsc)/./node_modules/uncrypto/dist/crypto.node.mjs\");\n/* harmony import */ var rou3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rou3 */ \"(rsc)/./node_modules/rou3/dist/index.mjs\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/error.ts\nfunction isErrorStackTraceLimitWritable() {\n  const desc = Object.getOwnPropertyDescriptor(Error, \"stackTraceLimit\");\n  if (desc === void 0) {\n    return Object.isExtensible(Error);\n  }\n  return Object.prototype.hasOwnProperty.call(desc, \"writable\") ? desc.writable : desc.set !== void 0;\n}\nfunction hideInternalStackFrames(stack) {\n  const lines = stack.split(\"\\n    at \");\n  if (lines.length <= 1) {\n    return stack;\n  }\n  lines.splice(1, 1);\n  return lines.join(\"\\n    at \");\n}\nfunction makeErrorForHideStackFrame(Base, clazz) {\n  class HideStackFramesError extends Base {\n    #hiddenStack;\n    constructor(...args) {\n      if (isErrorStackTraceLimitWritable()) {\n        const limit = Error.stackTraceLimit;\n        Error.stackTraceLimit = 0;\n        super(...args);\n        Error.stackTraceLimit = limit;\n      } else {\n        super(...args);\n      }\n      const stack = new Error().stack;\n      if (stack) {\n        this.#hiddenStack = hideInternalStackFrames(stack.replace(/^Error/, this.name));\n      }\n    }\n    // use `getter` here to avoid the stack trace being captured by loggers\n    get errorStack() {\n      return this.#hiddenStack;\n    }\n    // This is a workaround for wpt tests that expect that the error\n    // constructor has a `name` property of the base class.\n    get [\"constructor\"]() {\n      return clazz;\n    }\n  }\n  return HideStackFramesError;\n}\nvar _statusCode = {\n  OK: 200,\n  CREATED: 201,\n  ACCEPTED: 202,\n  NO_CONTENT: 204,\n  MULTIPLE_CHOICES: 300,\n  MOVED_PERMANENTLY: 301,\n  FOUND: 302,\n  SEE_OTHER: 303,\n  NOT_MODIFIED: 304,\n  TEMPORARY_REDIRECT: 307,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  NOT_ACCEPTABLE: 406,\n  PROXY_AUTHENTICATION_REQUIRED: 407,\n  REQUEST_TIMEOUT: 408,\n  CONFLICT: 409,\n  GONE: 410,\n  LENGTH_REQUIRED: 411,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  URI_TOO_LONG: 414,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  RANGE_NOT_SATISFIABLE: 416,\n  EXPECTATION_FAILED: 417,\n  \"I'M_A_TEAPOT\": 418,\n  MISDIRECTED_REQUEST: 421,\n  UNPROCESSABLE_ENTITY: 422,\n  LOCKED: 423,\n  FAILED_DEPENDENCY: 424,\n  TOO_EARLY: 425,\n  UPGRADE_REQUIRED: 426,\n  PRECONDITION_REQUIRED: 428,\n  TOO_MANY_REQUESTS: 429,\n  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n  HTTP_VERSION_NOT_SUPPORTED: 505,\n  VARIANT_ALSO_NEGOTIATES: 506,\n  INSUFFICIENT_STORAGE: 507,\n  LOOP_DETECTED: 508,\n  NOT_EXTENDED: 510,\n  NETWORK_AUTHENTICATION_REQUIRED: 511\n};\nvar InternalAPIError = class extends Error {\n  constructor(status = \"INTERNAL_SERVER_ERROR\", body = void 0, headers = {}, statusCode = typeof status === \"number\" ? status : _statusCode[status]) {\n    super(\n      body?.message,\n      body?.cause ? {\n        cause: body.cause\n      } : void 0\n    );\n    this.status = status;\n    this.body = body;\n    this.headers = headers;\n    this.statusCode = statusCode;\n    this.name = \"APIError\";\n    this.status = status;\n    this.headers = headers;\n    this.statusCode = statusCode;\n    this.body = body ? {\n      code: body?.message?.toUpperCase().replace(/ /g, \"_\").replace(/[^A-Z0-9_]/g, \"\"),\n      ...body\n    } : void 0;\n  }\n};\nvar APIError = makeErrorForHideStackFrame(InternalAPIError, Error);\n\n// src/utils.ts\nasync function getBody(request) {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (!request.body) {\n    return void 0;\n  }\n  if (contentType.includes(\"application/json\")) {\n    return await request.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value.toString();\n    });\n    return result;\n  }\n  if (contentType.includes(\"multipart/form-data\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value;\n    });\n    return result;\n  }\n  if (contentType.includes(\"text/plain\")) {\n    return await request.text();\n  }\n  if (contentType.includes(\"application/octet-stream\")) {\n    return await request.arrayBuffer();\n  }\n  if (contentType.includes(\"application/pdf\") || contentType.includes(\"image/\") || contentType.includes(\"video/\")) {\n    const blob = await request.blob();\n    return blob;\n  }\n  if (contentType.includes(\"application/stream\") || request.body instanceof ReadableStream) {\n    return request.body;\n  }\n  return await request.text();\n}\nfunction isAPIError(error) {\n  return error instanceof APIError || error?.name === \"APIError\";\n}\nfunction tryDecode(str) {\n  try {\n    return str.includes(\"%\") ? decodeURIComponent(str) : str;\n  } catch {\n    return str;\n  }\n}\n\n// src/to-response.ts\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nfunction safeStringify(obj, replacer, space) {\n  let id = 0;\n  const seen = /* @__PURE__ */ new WeakMap();\n  const safeReplacer = (key, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    if (typeof value === \"object\" && value !== null) {\n      if (seen.has(value)) {\n        return `[Circular ref-${seen.get(value)}]`;\n      }\n      seen.set(value, id++);\n    }\n    if (replacer) {\n      return replacer(key, value);\n    }\n    return value;\n  };\n  return JSON.stringify(obj, safeReplacer, space);\n}\nfunction isJSONResponse(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n  return \"_flag\" in value && value._flag === \"json\";\n}\nfunction toResponse(data, init) {\n  if (data instanceof Response) {\n    if (init?.headers instanceof Headers) {\n      init.headers.forEach((value, key) => {\n        data.headers.set(key, value);\n      });\n    }\n    return data;\n  }\n  const isJSON = isJSONResponse(data);\n  if (isJSON) {\n    const body2 = data.body;\n    const routerResponse = data.routerResponse;\n    if (routerResponse instanceof Response) {\n      return routerResponse;\n    }\n    const headers2 = new Headers({\n      ...routerResponse?.headers,\n      ...data.headers,\n      ...init?.headers,\n      \"Content-Type\": \"application/json\"\n    });\n    return new Response(JSON.stringify(body2), {\n      ...routerResponse,\n      headers: headers2,\n      status: data.status ?? init?.status ?? routerResponse?.status,\n      statusText: init?.statusText ?? routerResponse?.statusText\n    });\n  }\n  if (isAPIError(data)) {\n    return toResponse(data.body, {\n      status: init?.status ?? data.statusCode,\n      statusText: data.status.toString(),\n      headers: init?.headers || data.headers\n    });\n  }\n  let body = data;\n  let headers = new Headers(init?.headers);\n  if (!data) {\n    if (data === null) {\n      body = JSON.stringify(null);\n    }\n    headers.set(\"content-type\", \"application/json\");\n  } else if (typeof data === \"string\") {\n    body = data;\n    headers.set(\"Content-Type\", \"text/plain\");\n  } else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/octet-stream\");\n  } else if (data instanceof Blob) {\n    body = data;\n    headers.set(\"Content-Type\", data.type || \"application/octet-stream\");\n  } else if (data instanceof FormData) {\n    body = data;\n  } else if (data instanceof URLSearchParams) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n  } else if (data instanceof ReadableStream) {\n    body = data;\n    headers.set(\"Content-Type\", \"application/octet-stream\");\n  } else if (isJSONSerializable(data)) {\n    body = safeStringify(data);\n    headers.set(\"Content-Type\", \"application/json\");\n  }\n  return new Response(body, {\n    ...init,\n    headers\n  });\n}\n\n// src/validator.ts\nasync function runValidation(options, context = {}) {\n  let request = {\n    body: context.body,\n    query: context.query\n  };\n  if (options.body) {\n    const result = await options.body[\"~standard\"].validate(context.body);\n    if (result.issues) {\n      return {\n        data: null,\n        error: fromError(result.issues, \"body\")\n      };\n    }\n    request.body = result.value;\n  }\n  if (options.query) {\n    const result = await options.query[\"~standard\"].validate(context.query);\n    if (result.issues) {\n      return {\n        data: null,\n        error: fromError(result.issues, \"query\")\n      };\n    }\n    request.query = result.value;\n  }\n  if (options.requireHeaders && !context.headers) {\n    return {\n      data: null,\n      error: { message: \"Headers is required\" }\n    };\n  }\n  if (options.requireRequest && !context.request) {\n    return {\n      data: null,\n      error: { message: \"Request is required\" }\n    };\n  }\n  return {\n    data: request,\n    error: null\n  };\n}\nfunction fromError(error, validating) {\n  const errorMessages = [];\n  for (const issue2 of error) {\n    const message = issue2.message;\n    errorMessages.push(message);\n  }\n  return {\n    message: `Invalid ${validating} parameters`\n  };\n}\n\n// src/crypto.ts\n\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch (e) {\n    return false;\n  }\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await uncrypto__WEBPACK_IMPORTED_MODULE_0__.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar signCookieValue = async (value, secret) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return value;\n};\n\n// src/cookies.ts\nvar getCookieKey = (key, prefix) => {\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    } else {\n      return void 0;\n    }\n  }\n  return finalKey;\n};\nfunction parseCookies(str) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  const cookies = /* @__PURE__ */ new Map();\n  let index = 0;\n  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n    if (eqIdx === -1) {\n      break;\n    }\n    let endIdx = str.indexOf(\";\", index);\n    if (endIdx === -1) {\n      endIdx = str.length;\n    } else if (endIdx < eqIdx) {\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    const key = str.slice(index, eqIdx).trim();\n    if (!cookies.has(key)) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n      if (val.codePointAt(0) === 34) {\n        val = val.slice(1, -1);\n      }\n      cookies.set(key, tryDecode(val));\n    }\n    index = endIdx + 1;\n  }\n  return cookies;\n}\nvar _serialize = (key, value, opt = {}) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = `${`__Secure-${key}`}=${value}`;\n  } else if (opt?.prefix === \"host\") {\n    cookie = `${`__Host-${key}`}=${value}`;\n  } else {\n    cookie = `${key}=${value}`;\n  }\n  if (key.startsWith(\"__Secure-\") && !opt.secure) {\n    opt.secure = true;\n  }\n  if (key.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    if (opt.path !== \"/\") {\n      opt.path = \"/\";\n    }\n    if (opt.domain) {\n      opt.domain = void 0;\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serializeCookie = (key, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(key, value, opt);\n};\nvar serializeSignedCookie = async (key, value, secret, opt) => {\n  value = await signCookieValue(value, secret);\n  return _serialize(key, value, opt);\n};\n\n// src/context.ts\nvar createInternalContext = async (context, {\n  options,\n  path\n}) => {\n  const headers = new Headers();\n  const { data, error } = await runValidation(options, context);\n  if (error) {\n    throw new APIError(400, {\n      message: error.message,\n      code: \"VALIDATION_ERROR\"\n    });\n  }\n  const requestHeaders = \"headers\" in context ? context.headers instanceof Headers ? context.headers : new Headers(context.headers) : \"request\" in context && context.request instanceof Request ? context.request.headers : null;\n  const requestCookies = requestHeaders?.get(\"cookie\");\n  const parsedCookies = requestCookies ? parseCookies(requestCookies) : void 0;\n  const internalContext = {\n    ...context,\n    body: data.body,\n    query: data.query,\n    path: context.path || path,\n    context: \"context\" in context && context.context ? context.context : {},\n    returned: void 0,\n    headers: context?.headers,\n    request: context?.request,\n    params: \"params\" in context ? context.params : void 0,\n    method: context.method,\n    setHeader: (key, value) => {\n      headers.set(key, value);\n    },\n    getHeader: (key) => {\n      if (!requestHeaders) return null;\n      return requestHeaders.get(key);\n    },\n    getCookie: (key, prefix) => {\n      const finalKey = getCookieKey(key, prefix);\n      if (!finalKey) {\n        return null;\n      }\n      return parsedCookies?.get(finalKey) || null;\n    },\n    getSignedCookie: async (key, secret, prefix) => {\n      const finalKey = getCookieKey(key, prefix);\n      if (!finalKey) {\n        return null;\n      }\n      const value = parsedCookies?.get(finalKey);\n      if (!value) {\n        return null;\n      }\n      const signatureStartPos = value.lastIndexOf(\".\");\n      if (signatureStartPos < 1) {\n        return null;\n      }\n      const signedValue = value.substring(0, signatureStartPos);\n      const signature = value.substring(signatureStartPos + 1);\n      if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n        return null;\n      }\n      const secretKey = await getCryptoKey(secret);\n      const isVerified = await verifySignature(signature, signedValue, secretKey);\n      return isVerified ? signedValue : false;\n    },\n    setCookie: (key, value, options2) => {\n      const cookie = serializeCookie(key, value, options2);\n      headers.append(\"set-cookie\", cookie);\n      return cookie;\n    },\n    setSignedCookie: async (key, value, secret, options2) => {\n      const cookie = await serializeSignedCookie(key, value, secret, options2);\n      headers.append(\"set-cookie\", cookie);\n      return cookie;\n    },\n    redirect: (url) => {\n      headers.set(\"location\", url);\n      return new APIError(\"FOUND\", void 0, headers);\n    },\n    error: (status, body, headers2) => {\n      return new APIError(status, body, headers2);\n    },\n    json: (json, routerResponse) => {\n      if (!context.asResponse) {\n        return json;\n      }\n      return {\n        body: routerResponse?.body || json,\n        routerResponse,\n        _flag: \"json\"\n      };\n    },\n    responseHeaders: headers\n  };\n  for (const middleware of options.use || []) {\n    const response = await middleware({\n      ...internalContext,\n      returnHeaders: true,\n      asResponse: false\n    });\n    if (response.response) {\n      Object.assign(internalContext.context, response.response);\n    }\n    if (response.headers) {\n      response.headers.forEach((value, key) => {\n        internalContext.responseHeaders.set(key, value);\n      });\n    }\n  }\n  return internalContext;\n};\n\n// src/middleware.ts\nfunction createMiddleware(optionsOrHandler, handler) {\n  const internalHandler = async (inputCtx) => {\n    const context = inputCtx;\n    const _handler = typeof optionsOrHandler === \"function\" ? optionsOrHandler : handler;\n    const options = typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler;\n    const internalContext = await createInternalContext(context, {\n      options,\n      path: \"/\"\n    });\n    if (!_handler) {\n      throw new Error(\"handler must be defined\");\n    }\n    const response = await _handler(internalContext);\n    const headers = internalContext.responseHeaders;\n    return context.returnHeaders ? {\n      headers,\n      response\n    } : response;\n  };\n  internalHandler.options = typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler;\n  return internalHandler;\n}\ncreateMiddleware.create = (opts) => {\n  function fn(optionsOrHandler, handler) {\n    if (typeof optionsOrHandler === \"function\") {\n      return createMiddleware(\n        {\n          use: opts?.use\n        },\n        optionsOrHandler\n      );\n    }\n    if (!handler) {\n      throw new Error(\"Middleware handler is required\");\n    }\n    const middleware = createMiddleware(\n      {\n        ...optionsOrHandler,\n        method: \"*\",\n        use: [...opts?.use || [], ...optionsOrHandler.use || []]\n      },\n      handler\n    );\n    return middleware;\n  }\n  return fn;\n};\n\n// src/endpoint.ts\nvar createEndpoint2 = (path, options, handler) => {\n  const internalHandler = async (...inputCtx) => {\n    const context = inputCtx[0] || {};\n    const internalContext = await createInternalContext(context, {\n      options,\n      path\n    });\n    const response = await handler(internalContext).catch(async (e) => {\n      if (isAPIError(e)) {\n        const onAPIError = options.onAPIError;\n        if (onAPIError) {\n          await onAPIError(e);\n        }\n        if (context.asResponse) {\n          return e;\n        }\n      }\n      throw e;\n    });\n    const headers = internalContext.responseHeaders;\n    return context.asResponse ? toResponse(response, {\n      headers\n    }) : context.returnHeaders ? {\n      headers,\n      response\n    } : response;\n  };\n  internalHandler.options = options;\n  internalHandler.path = path;\n  return internalHandler;\n};\ncreateEndpoint2.create = (opts) => {\n  return (path, options, handler) => {\n    return createEndpoint2(\n      path,\n      {\n        ...options,\n        use: [...options?.use || [], ...opts?.use || []]\n      },\n      handler\n    );\n  };\n};\n\n// src/router.ts\n\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/core.js\nvar NEVER = Object.freeze({\n  status: \"aborted\"\n});\n// @__NO_SIDE_EFFECTS__\nfunction $constructor(name, initializer3, params) {\n  function init(inst, def) {\n    var _a;\n    Object.defineProperty(inst, \"_zod\", {\n      value: inst._zod ?? {},\n      enumerable: false\n    });\n    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());\n    inst._zod.traits.add(name);\n    initializer3(inst, def);\n    for (const k in _.prototype) {\n      if (!(k in inst))\n        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n    }\n    inst._zod.constr = _;\n    inst._zod.def = def;\n  }\n  const Parent = params?.Parent ?? Object;\n  class Definition extends Parent {\n  }\n  Object.defineProperty(Definition, \"name\", { value: name });\n  function _(def) {\n    var _a;\n    const inst = params?.Parent ? new Definition() : this;\n    init(inst, def);\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }\n  Object.defineProperty(_, \"init\", { value: init });\n  Object.defineProperty(_, Symbol.hasInstance, {\n    value: (inst) => {\n      if (params?.Parent && inst instanceof params.Parent)\n        return true;\n      return inst?._zod?.traits?.has(name);\n    }\n  });\n  Object.defineProperty(_, \"name\", { value: name });\n  return _;\n}\nvar $brand = Symbol(\"zod_brand\");\nvar $ZodAsyncError = class extends Error {\n  constructor() {\n    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n  }\n};\nvar globalConfig = {};\nfunction config(newConfig) {\n  if (newConfig)\n    Object.assign(globalConfig, newConfig);\n  return globalConfig;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/util.js\nvar util_exports = {};\n__export(util_exports, {\n  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,\n  Class: () => Class,\n  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,\n  aborted: () => aborted,\n  allowsEval: () => allowsEval,\n  assert: () => assert,\n  assertEqual: () => assertEqual,\n  assertIs: () => assertIs,\n  assertNever: () => assertNever,\n  assertNotEqual: () => assertNotEqual,\n  assignProp: () => assignProp,\n  cached: () => cached,\n  captureStackTrace: () => captureStackTrace,\n  cleanEnum: () => cleanEnum,\n  cleanRegex: () => cleanRegex,\n  clone: () => clone,\n  createTransparentProxy: () => createTransparentProxy,\n  defineLazy: () => defineLazy,\n  esc: () => esc,\n  escapeRegex: () => escapeRegex,\n  extend: () => extend,\n  finalizeIssue: () => finalizeIssue,\n  floatSafeRemainder: () => floatSafeRemainder,\n  getElementAtPath: () => getElementAtPath,\n  getEnumValues: () => getEnumValues,\n  getLengthableOrigin: () => getLengthableOrigin,\n  getParsedType: () => getParsedType,\n  getSizableOrigin: () => getSizableOrigin,\n  isObject: () => isObject,\n  isPlainObject: () => isPlainObject,\n  issue: () => issue,\n  joinValues: () => joinValues,\n  jsonStringifyReplacer: () => jsonStringifyReplacer,\n  merge: () => merge,\n  normalizeParams: () => normalizeParams,\n  nullish: () => nullish,\n  numKeys: () => numKeys,\n  omit: () => omit,\n  optionalKeys: () => optionalKeys,\n  partial: () => partial,\n  pick: () => pick,\n  prefixIssues: () => prefixIssues,\n  primitiveTypes: () => primitiveTypes,\n  promiseAllObject: () => promiseAllObject,\n  propertyKeyTypes: () => propertyKeyTypes,\n  randomString: () => randomString,\n  required: () => required,\n  stringifyPrimitive: () => stringifyPrimitive,\n  unwrapMessage: () => unwrapMessage\n});\nfunction assertEqual(val) {\n  return val;\n}\nfunction assertNotEqual(val) {\n  return val;\n}\nfunction assertIs(_arg) {\n}\nfunction assertNever(_x) {\n  throw new Error();\n}\nfunction assert(_) {\n}\nfunction getEnumValues(entries) {\n  const numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);\n  return values;\n}\nfunction joinValues(array2, separator = \"|\") {\n  return array2.map((val) => stringifyPrimitive(val)).join(separator);\n}\nfunction jsonStringifyReplacer(_, value) {\n  if (typeof value === \"bigint\")\n    return value.toString();\n  return value;\n}\nfunction cached(getter) {\n  const set = false;\n  return {\n    get value() {\n      if (!set) {\n        const value = getter();\n        Object.defineProperty(this, \"value\", { value });\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    }\n  };\n}\nfunction nullish(input) {\n  return input === null || input === void 0;\n}\nfunction cleanRegex(source) {\n  const start = source.startsWith(\"^\") ? 1 : 0;\n  const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / 10 ** decCount;\n}\nfunction defineLazy(object, key, getter) {\n  const set = false;\n  Object.defineProperty(object, key, {\n    get() {\n      if (!set) {\n        const value = getter();\n        object[key] = value;\n        return value;\n      }\n      throw new Error(\"cached value already set\");\n    },\n    set(v) {\n      Object.defineProperty(object, key, {\n        value: v\n        // configurable: true,\n      });\n    },\n    configurable: true\n  });\n}\nfunction assignProp(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction getElementAtPath(obj, path) {\n  if (!path)\n    return obj;\n  return path.reduce((acc, key) => acc?.[key], obj);\n}\nfunction promiseAllObject(promisesObj) {\n  const keys = Object.keys(promisesObj);\n  const promises = keys.map((key) => promisesObj[key]);\n  return Promise.all(promises).then((results) => {\n    const resolvedObj = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObj[keys[i]] = results[i];\n    }\n    return resolvedObj;\n  });\n}\nfunction randomString(length = 10) {\n  const chars = \"abcdefghijklmnopqrstuvwxyz\";\n  let str = \"\";\n  for (let i = 0; i < length; i++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}\nfunction esc(str) {\n  return JSON.stringify(str);\n}\nvar captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {\n};\nfunction isObject(data) {\n  return typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nvar allowsEval = cached(() => {\n  if (typeof navigator !== \"undefined\" && navigator?.userAgent?.includes(\"Cloudflare\")) {\n    return false;\n  }\n  try {\n    const F = Function;\n    new F(\"\");\n    return true;\n  } catch (_) {\n    return false;\n  }\n});\nfunction isPlainObject(o) {\n  if (isObject(o) === false)\n    return false;\n  const ctor = o.constructor;\n  if (ctor === void 0)\n    return true;\n  const prot = ctor.prototype;\n  if (isObject(prot) === false)\n    return false;\n  if (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nfunction numKeys(data) {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"string\":\n      return \"string\";\n    case \"number\":\n      return Number.isNaN(data) ? \"nan\" : \"number\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"function\":\n      return \"function\";\n    case \"bigint\":\n      return \"bigint\";\n    case \"symbol\":\n      return \"symbol\";\n    case \"object\":\n      if (Array.isArray(data)) {\n        return \"array\";\n      }\n      if (data === null) {\n        return \"null\";\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return \"promise\";\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return \"map\";\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return \"set\";\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return \"date\";\n      }\n      if (typeof File !== \"undefined\" && data instanceof File) {\n        return \"file\";\n      }\n      return \"object\";\n    default:\n      throw new Error(`Unknown data type: ${t}`);\n  }\n};\nvar propertyKeyTypes = /* @__PURE__ */ new Set([\"string\", \"number\", \"symbol\"]);\nvar primitiveTypes = /* @__PURE__ */ new Set([\"string\", \"number\", \"bigint\", \"boolean\", \"symbol\", \"undefined\"]);\nfunction escapeRegex(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction clone(inst, def, params) {\n  const cl = new inst._zod.constr(def ?? inst._zod.def);\n  if (!def || params?.parent)\n    cl._zod.parent = inst;\n  return cl;\n}\nfunction normalizeParams(_params) {\n  const params = _params;\n  if (!params)\n    return {};\n  if (typeof params === \"string\")\n    return { error: () => params };\n  if (params?.message !== void 0) {\n    if (params?.error !== void 0)\n      throw new Error(\"Cannot specify both `message` and `error` params\");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === \"string\")\n    return { ...params, error: () => params.error };\n  return params;\n}\nfunction createTransparentProxy(getter) {\n  let target;\n  return new Proxy({}, {\n    get(_, prop, receiver) {\n      target ?? (target = getter());\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_, prop, value, receiver) {\n      target ?? (target = getter());\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_, prop) {\n      target ?? (target = getter());\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_, prop) {\n      target ?? (target = getter());\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_) {\n      target ?? (target = getter());\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_, prop) {\n      target ?? (target = getter());\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_, prop, descriptor) {\n      target ?? (target = getter());\n      return Reflect.defineProperty(target, prop, descriptor);\n    }\n  });\n}\nfunction stringifyPrimitive(value) {\n  if (typeof value === \"bigint\")\n    return value.toString() + \"n\";\n  if (typeof value === \"string\")\n    return `\"${value}\"`;\n  return `${value}`;\n}\nfunction optionalKeys(shape) {\n  return Object.keys(shape).filter((k) => {\n    return shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n  });\n}\nvar NUMBER_FORMAT_RANGES = {\n  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n  int32: [-2147483648, 2147483647],\n  uint32: [0, 4294967295],\n  float32: [-34028234663852886e22, 34028234663852886e22],\n  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]\n};\nvar BIGINT_FORMAT_RANGES = {\n  int64: [/* @__PURE__ */ BigInt(\"-9223372036854775808\"), /* @__PURE__ */ BigInt(\"9223372036854775807\")],\n  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt(\"18446744073709551615\")]\n};\nfunction pick(schema, mask) {\n  const newShape = {};\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key])\n      continue;\n    newShape[key] = currDef.shape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction omit(schema, mask) {\n  const newShape = { ...schema._zod.def.shape };\n  const currDef = schema._zod.def;\n  for (const key in mask) {\n    if (!(key in currDef.shape)) {\n      throw new Error(`Unrecognized key: \"${key}\"`);\n    }\n    if (!mask[key])\n      continue;\n    delete newShape[key];\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape: newShape,\n    checks: []\n  });\n}\nfunction extend(schema, shape) {\n  if (!isPlainObject(shape)) {\n    throw new Error(\"Invalid input to extend: expected a plain object\");\n  }\n  const def = {\n    ...schema._zod.def,\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, \"shape\", _shape);\n      return _shape;\n    },\n    checks: []\n    // delete existing checks\n  };\n  return clone(schema, def);\n}\nfunction merge(a, b) {\n  return clone(a, {\n    ...a._zod.def,\n    get shape() {\n      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n      assignProp(this, \"shape\", _shape);\n      return _shape;\n    },\n    catchall: b._zod.def.catchall,\n    checks: []\n    // delete existing checks\n  });\n}\nfunction partial(Class2, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = { ...oldShape };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in oldShape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!mask[key])\n        continue;\n      shape[key] = Class2 ? new Class2({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = Class2 ? new Class2({\n        type: \"optional\",\n        innerType: oldShape[key]\n      }) : oldShape[key];\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    checks: []\n  });\n}\nfunction required(Class2, schema, mask) {\n  const oldShape = schema._zod.def.shape;\n  const shape = { ...oldShape };\n  if (mask) {\n    for (const key in mask) {\n      if (!(key in shape)) {\n        throw new Error(`Unrecognized key: \"${key}\"`);\n      }\n      if (!mask[key])\n        continue;\n      shape[key] = new Class2({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  } else {\n    for (const key in oldShape) {\n      shape[key] = new Class2({\n        type: \"nonoptional\",\n        innerType: oldShape[key]\n      });\n    }\n  }\n  return clone(schema, {\n    ...schema._zod.def,\n    shape,\n    // optional: [],\n    checks: []\n  });\n}\nfunction aborted(x, startIndex = 0) {\n  for (let i = startIndex; i < x.issues.length; i++) {\n    if (x.issues[i]?.continue !== true)\n      return true;\n  }\n  return false;\n}\nfunction prefixIssues(path, issues) {\n  return issues.map((iss) => {\n    var _a;\n    (_a = iss).path ?? (_a.path = []);\n    iss.path.unshift(path);\n    return iss;\n  });\n}\nfunction unwrapMessage(message) {\n  return typeof message === \"string\" ? message : message?.message;\n}\nfunction finalizeIssue(iss, ctx, config2) {\n  const full = { ...iss, path: iss.path ?? [] };\n  if (!iss.message) {\n    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? \"Invalid input\";\n    full.message = message;\n  }\n  delete full.inst;\n  delete full.continue;\n  if (!ctx?.reportInput) {\n    delete full.input;\n  }\n  return full;\n}\nfunction getSizableOrigin(input) {\n  if (input instanceof Set)\n    return \"set\";\n  if (input instanceof Map)\n    return \"map\";\n  if (input instanceof File)\n    return \"file\";\n  return \"unknown\";\n}\nfunction getLengthableOrigin(input) {\n  if (Array.isArray(input))\n    return \"array\";\n  if (typeof input === \"string\")\n    return \"string\";\n  return \"unknown\";\n}\nfunction issue(...args) {\n  const [iss, input, inst] = args;\n  if (typeof iss === \"string\") {\n    return {\n      message: iss,\n      code: \"custom\",\n      input,\n      inst\n    };\n  }\n  return { ...iss };\n}\nfunction cleanEnum(obj) {\n  return Object.entries(obj).filter(([k, _]) => {\n    return Number.isNaN(Number.parseInt(k, 10));\n  }).map((el) => el[1]);\n}\nvar Class = class {\n  constructor(..._args) {\n  }\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/errors.js\nvar initializer = (inst, def) => {\n  inst.name = \"$ZodError\";\n  Object.defineProperty(inst, \"_zod\", {\n    value: inst._zod,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"issues\", {\n    value: def,\n    enumerable: false\n  });\n  Object.defineProperty(inst, \"message\", {\n    get() {\n      return JSON.stringify(def, jsonStringifyReplacer, 2);\n    },\n    enumerable: true\n    // configurable: false,\n  });\n  Object.defineProperty(inst, \"toString\", {\n    value: () => inst.message,\n    enumerable: false\n  });\n};\nvar $ZodError = $constructor(\"$ZodError\", initializer);\nvar $ZodRealError = $constructor(\"$ZodError\", initializer, { Parent: Error });\nfunction flattenError(error, mapper = (issue2) => issue2.message) {\n  const fieldErrors = {};\n  const formErrors = [];\n  for (const sub of error.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n      fieldErrors[sub.path[0]].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return { formErrors, fieldErrors };\n}\nfunction formatError(error, _mapper) {\n  const mapper = _mapper || function(issue2) {\n    return issue2.message;\n  };\n  const fieldErrors = { _errors: [] };\n  const processError = (error2) => {\n    for (const issue2 of error2.issues) {\n      if (issue2.code === \"invalid_union\" && issue2.errors.length) {\n        issue2.errors.map((issues) => processError({ issues }));\n      } else if (issue2.code === \"invalid_key\") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.code === \"invalid_element\") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.path.length === 0) {\n        fieldErrors._errors.push(mapper(issue2));\n      } else {\n        let curr = fieldErrors;\n        let i = 0;\n        while (i < issue2.path.length) {\n          const el = issue2.path[i];\n          const terminal = i === issue2.path.length - 1;\n          if (!terminal) {\n            curr[el] = curr[el] || { _errors: [] };\n          } else {\n            curr[el] = curr[el] || { _errors: [] };\n            curr[el]._errors.push(mapper(issue2));\n          }\n          curr = curr[el];\n          i++;\n        }\n      }\n    }\n  };\n  processError(error);\n  return fieldErrors;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/parse.js\nvar _parse = (_Err) => (schema, value, _ctx, _params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  if (result.issues.length) {\n    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, _params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar _parseAsync = (_Err) => async (schema, value, _ctx, params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  if (result.issues.length) {\n    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar _safeParse = (_Err) => (schema, value, _ctx) => {\n  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  return result.issues.length ? {\n    success: false,\n    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParse = /* @__PURE__ */ _safeParse($ZodRealError);\nvar _safeParseAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  return result.issues.length ? {\n    success: false,\n    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/checks.js\nvar $ZodCheck = /* @__PURE__ */ $constructor(\"$ZodCheck\", (inst, def) => {\n  var _a;\n  inst._zod ?? (inst._zod = {});\n  inst._zod.def = def;\n  (_a = inst._zod).onattach ?? (_a.onattach = []);\n});\nvar $ZodCheckMaxLength = /* @__PURE__ */ $constructor(\"$ZodCheckMaxLength\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n    if (def.maximum < curr)\n      inst2._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length <= def.maximum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_big\",\n      maximum: def.maximum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMinLength = /* @__PURE__ */ $constructor(\"$ZodCheckMinLength\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr)\n      inst2._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length >= def.minimum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: \"too_small\",\n      minimum: def.minimum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLengthEquals = /* @__PURE__ */ $constructor(\"$ZodCheckLengthEquals\", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.minimum = def.length;\n    bag.maximum = def.length;\n    bag.length = def.length;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length === def.length)\n      return;\n    const origin = getLengthableOrigin(input);\n    const tooBig = length > def.length;\n    payload.issues.push({\n      origin,\n      ...tooBig ? { code: \"too_big\", maximum: def.length } : { code: \"too_small\", minimum: def.length },\n      inclusive: true,\n      exact: true,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckOverwrite = /* @__PURE__ */ $constructor(\"$ZodCheckOverwrite\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = (payload) => {\n    payload.value = def.tx(payload.value);\n  };\n});\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/doc.js\nvar Doc = class {\n  constructor(args = []) {\n    this.content = [];\n    this.indent = 0;\n    if (this)\n      this.args = args;\n  }\n  indented(fn) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }\n  write(arg) {\n    if (typeof arg === \"function\") {\n      arg(this, { execution: \"sync\" });\n      arg(this, { execution: \"async\" });\n      return;\n    }\n    const content = arg;\n    const lines = content.split(\"\\n\").filter((x) => x);\n    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => \" \".repeat(this.indent * 2) + x);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }\n  compile() {\n    const F = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map((x) => `  ${x}`)];\n    return new F(...args, lines.join(\"\\n\"));\n  }\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/versions.js\nvar version = {\n  major: 4,\n  minor: 0,\n  patch: 0\n};\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/schemas.js\nvar $ZodType = /* @__PURE__ */ $constructor(\"$ZodType\", (inst, def) => {\n  var _a;\n  inst ?? (inst = {});\n  inst._zod.def = def;\n  inst._zod.bag = inst._zod.bag || {};\n  inst._zod.version = version;\n  const checks = [...inst._zod.def.checks ?? []];\n  if (inst._zod.traits.has(\"$ZodCheck\")) {\n    checks.unshift(inst);\n  }\n  for (const ch of checks) {\n    for (const fn of ch._zod.onattach) {\n      fn(inst);\n    }\n  }\n  if (checks.length === 0) {\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    inst._zod.deferred?.push(() => {\n      inst._zod.run = inst._zod.parse;\n    });\n  } else {\n    const runChecks = (payload, checks2, ctx) => {\n      let isAborted = aborted(payload);\n      let asyncResult;\n      for (const ch of checks2) {\n        if (ch._zod.def.when) {\n          const shouldRun = ch._zod.def.when(payload);\n          if (!shouldRun)\n            continue;\n        } else if (isAborted) {\n          continue;\n        }\n        const currLen = payload.issues.length;\n        const _ = ch._zod.check(payload);\n        if (_ instanceof Promise && ctx?.async === false) {\n          throw new $ZodAsyncError();\n        }\n        if (asyncResult || _ instanceof Promise) {\n          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n            await _;\n            const nextLen = payload.issues.length;\n            if (nextLen === currLen)\n              return;\n            if (!isAborted)\n              isAborted = aborted(payload, currLen);\n          });\n        } else {\n          const nextLen = payload.issues.length;\n          if (nextLen === currLen)\n            continue;\n          if (!isAborted)\n            isAborted = aborted(payload, currLen);\n        }\n      }\n      if (asyncResult) {\n        return asyncResult.then(() => {\n          return payload;\n        });\n      }\n      return payload;\n    };\n    inst._zod.run = (payload, ctx) => {\n      const result = inst._zod.parse(payload, ctx);\n      if (result instanceof Promise) {\n        if (ctx.async === false)\n          throw new $ZodAsyncError();\n        return result.then((result2) => runChecks(result2, checks, ctx));\n      }\n      return runChecks(result, checks, ctx);\n    };\n  }\n  inst[\"~standard\"] = {\n    validate: (value) => {\n      try {\n        const r = safeParse(inst, value);\n        return r.success ? { value: r.data } : { issues: r.error?.issues };\n      } catch (_) {\n        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });\n      }\n    },\n    vendor: \"zod\",\n    version: 1\n  };\n});\nvar $ZodUnknown = /* @__PURE__ */ $constructor(\"$ZodUnknown\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload) => payload;\n});\nvar $ZodNever = /* @__PURE__ */ $constructor(\"$ZodNever\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.issues.push({\n      expected: \"never\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nfunction handleArrayResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nvar $ZodArray = /* @__PURE__ */ $constructor(\"$ZodArray\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        expected: \"array\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = Array(input.length);\n    const proms = [];\n    for (let i = 0; i < input.length; i++) {\n      const item = input[i];\n      const result = def.element._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));\n      } else {\n        handleArrayResult(result, payload, i);\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nfunction handleObjectResult(result, final, key) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(key, result.issues));\n  }\n  final.value[key] = result.value;\n}\nfunction handleOptionalObjectResult(result, final, key, input) {\n  if (result.issues.length) {\n    if (input[key] === void 0) {\n      if (key in input) {\n        final.value[key] = void 0;\n      } else {\n        final.value[key] = result.value;\n      }\n    } else {\n      final.issues.push(...prefixIssues(key, result.issues));\n    }\n  } else if (result.value === void 0) {\n    if (key in input)\n      final.value[key] = void 0;\n  } else {\n    final.value[key] = result.value;\n  }\n}\nvar $ZodObject = /* @__PURE__ */ $constructor(\"$ZodObject\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const _normalized = cached(() => {\n    const keys = Object.keys(def.shape);\n    for (const k of keys) {\n      if (!(def.shape[k] instanceof $ZodType)) {\n        throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n      }\n    }\n    const okeys = optionalKeys(def.shape);\n    return {\n      shape: def.shape,\n      keys,\n      keySet: new Set(keys),\n      numKeys: keys.length,\n      optionalKeys: new Set(okeys)\n    };\n  });\n  defineLazy(inst._zod, \"propValues\", () => {\n    const shape = def.shape;\n    const propValues = {};\n    for (const key in shape) {\n      const field = shape[key]._zod;\n      if (field.values) {\n        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());\n        for (const v of field.values)\n          propValues[key].add(v);\n      }\n    }\n    return propValues;\n  });\n  const generateFastpass = (shape) => {\n    const doc = new Doc([\"shape\", \"payload\", \"ctx\"]);\n    const normalized = _normalized.value;\n    const parseStr = (key) => {\n      const k = esc(key);\n      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n    };\n    doc.write(`const input = payload.value;`);\n    const ids = /* @__PURE__ */ Object.create(null);\n    let counter = 0;\n    for (const key of normalized.keys) {\n      ids[key] = `key_${counter++}`;\n    }\n    doc.write(`const newResult = {}`);\n    for (const key of normalized.keys) {\n      if (normalized.optionalKeys.has(key)) {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        const k = esc(key);\n        doc.write(`\n        if (${id}.issues.length) {\n          if (input[${k}] === undefined) {\n            if (${k} in input) {\n              newResult[${k}] = undefined;\n            }\n          } else {\n            payload.issues = payload.issues.concat(\n              ${id}.issues.map((iss) => ({\n                ...iss,\n                path: iss.path ? [${k}, ...iss.path] : [${k}],\n              }))\n            );\n          }\n        } else if (${id}.value === undefined) {\n          if (${k} in input) newResult[${k}] = undefined;\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        `);\n      } else {\n        const id = ids[key];\n        doc.write(`const ${id} = ${parseStr(key)};`);\n        doc.write(`\n          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]\n          })));`);\n        doc.write(`newResult[${esc(key)}] = ${id}.value`);\n      }\n    }\n    doc.write(`payload.value = newResult;`);\n    doc.write(`return payload;`);\n    const fn = doc.compile();\n    return (payload, ctx) => fn(shape, payload, ctx);\n  };\n  let fastpass;\n  const isObject2 = isObject;\n  const jit = !globalConfig.jitless;\n  const allowsEval2 = allowsEval;\n  const fastEnabled = jit && allowsEval2.value;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject2(input)) {\n      payload.issues.push({\n        expected: \"object\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n      if (!fastpass)\n        fastpass = generateFastpass(def.shape);\n      payload = fastpass(payload, ctx);\n    } else {\n      payload.value = {};\n      const shape = value.shape;\n      for (const key of value.keys) {\n        const el = shape[key];\n        const r = el._zod.run({ value: input[key], issues: [] }, ctx);\n        const isOptional = el._zod.optin === \"optional\" && el._zod.optout === \"optional\";\n        if (r instanceof Promise) {\n          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));\n        } else if (isOptional) {\n          handleOptionalObjectResult(r, payload, key, input);\n        } else {\n          handleObjectResult(r, payload, key);\n        }\n      }\n    }\n    if (!catchall) {\n      return proms.length ? Promise.all(proms).then(() => payload) : payload;\n    }\n    const unrecognized = [];\n    const keySet = value.keySet;\n    const _catchall = catchall._zod;\n    const t = _catchall.def.type;\n    for (const key of Object.keys(input)) {\n      if (keySet.has(key))\n        continue;\n      if (t === \"never\") {\n        unrecognized.push(key);\n        continue;\n      }\n      const r = _catchall.run({ value: input[key], issues: [] }, ctx);\n      if (r instanceof Promise) {\n        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));\n      } else {\n        handleObjectResult(r, payload, key);\n      }\n    }\n    if (unrecognized.length) {\n      payload.issues.push({\n        code: \"unrecognized_keys\",\n        keys: unrecognized,\n        input,\n        inst\n      });\n    }\n    if (!proms.length)\n      return payload;\n    return Promise.all(proms).then(() => {\n      return payload;\n    });\n  };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n  final.issues.push({\n    code: \"invalid_union\",\n    input: final.value,\n    inst,\n    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  });\n  return final;\n}\nvar $ZodUnion = /* @__PURE__ */ $constructor(\"$ZodUnion\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"optin\", () => def.options.some((o) => o._zod.optin === \"optional\") ? \"optional\" : void 0);\n  defineLazy(inst._zod, \"optout\", () => def.options.some((o) => o._zod.optout === \"optional\") ? \"optional\" : void 0);\n  defineLazy(inst._zod, \"values\", () => {\n    if (def.options.every((o) => o._zod.values)) {\n      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));\n    }\n    return void 0;\n  });\n  defineLazy(inst._zod, \"pattern\", () => {\n    if (def.options.every((o) => o._zod.pattern)) {\n      const patterns = def.options.map((o) => o._zod.pattern);\n      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join(\"|\")})$`);\n    }\n    return void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    let async = false;\n    const results = [];\n    for (const option of def.options) {\n      const result = option._zod.run({\n        value: payload.value,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        if (result.issues.length === 0)\n          return result;\n        results.push(result);\n      }\n    }\n    if (!async)\n      return handleUnionResults(results, payload, inst, ctx);\n    return Promise.all(results).then((results2) => {\n      return handleUnionResults(results2, payload, inst, ctx);\n    });\n  };\n});\nvar $ZodIntersection = /* @__PURE__ */ $constructor(\"$ZodIntersection\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    const left = def.left._zod.run({ value: input, issues: [] }, ctx);\n    const right = def.right._zod.run({ value: input, issues: [] }, ctx);\n    const async = left instanceof Promise || right instanceof Promise;\n    if (async) {\n      return Promise.all([left, right]).then(([left2, right2]) => {\n        return handleIntersectionResults(payload, left2, right2);\n      });\n    }\n    return handleIntersectionResults(payload, left, right);\n  };\n});\nfunction mergeValues(a, b) {\n  if (a === b) {\n    return { valid: true, data: a };\n  }\n  if (a instanceof Date && b instanceof Date && +a === +b) {\n    return { valid: true, data: a };\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const bKeys = Object.keys(b);\n    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return { valid: false, mergeErrorPath: [] };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  }\n  return { valid: false, mergeErrorPath: [] };\n}\nfunction handleIntersectionResults(result, left, right) {\n  if (left.issues.length) {\n    result.issues.push(...left.issues);\n  }\n  if (right.issues.length) {\n    result.issues.push(...right.issues);\n  }\n  if (aborted(result))\n    return result;\n  const merged = mergeValues(left.value, right.value);\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n  result.value = merged.data;\n  return result;\n}\nvar $ZodEnum = /* @__PURE__ */ $constructor(\"$ZodEnum\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const values = getEnumValues(def.entries);\n  inst._zod.values = new Set(values);\n  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === \"string\" ? escapeRegex(o) : o.toString()).join(\"|\")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: \"invalid_value\",\n      values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodTransform = /* @__PURE__ */ $constructor(\"$ZodTransform\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const _out = def.transform(payload.value, payload);\n    if (_ctx.async) {\n      const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    if (_out instanceof Promise) {\n      throw new $ZodAsyncError();\n    }\n    payload.value = _out;\n    return payload;\n  };\n});\nvar $ZodOptional = /* @__PURE__ */ $constructor(\"$ZodOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  inst._zod.optout = \"optional\";\n  defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;\n  });\n  defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (def.innerType._zod.optin === \"optional\") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    if (payload.value === void 0) {\n      return payload;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNullable = /* @__PURE__ */ $constructor(\"$ZodNullable\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;\n  });\n  defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === null)\n      return payload;\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodDefault = /* @__PURE__ */ $constructor(\"$ZodDefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n      return payload;\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleDefaultResult(result2, def));\n    }\n    return handleDefaultResult(result, def);\n  };\n});\nfunction handleDefaultResult(payload, def) {\n  if (payload.value === void 0) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}\nvar $ZodPrefault = /* @__PURE__ */ $constructor(\"$ZodPrefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNonOptional = /* @__PURE__ */ $constructor(\"$ZodNonOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"values\", () => {\n    const v = def.innerType._zod.values;\n    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleNonOptionalResult(result2, inst));\n    }\n    return handleNonOptionalResult(result, inst);\n  };\n});\nfunction handleNonOptionalResult(payload, inst) {\n  if (!payload.issues.length && payload.value === void 0) {\n    payload.issues.push({\n      code: \"invalid_type\",\n      expected: \"nonoptional\",\n      input: payload.value,\n      inst\n    });\n  }\n  return payload;\n}\nvar $ZodCatch = /* @__PURE__ */ $constructor(\"$ZodCatch\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => {\n        payload.value = result2.value;\n        if (result2.issues.length) {\n          payload.value = def.catchValue({\n            ...payload,\n            error: {\n              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n            },\n            input: payload.value\n          });\n          payload.issues = [];\n        }\n        return payload;\n      });\n    }\n    payload.value = result.value;\n    if (result.issues.length) {\n      payload.value = def.catchValue({\n        ...payload,\n        error: {\n          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n        },\n        input: payload.value\n      });\n      payload.issues = [];\n    }\n    return payload;\n  };\n});\nvar $ZodPipe = /* @__PURE__ */ $constructor(\"$ZodPipe\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n  defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const left = def.in._zod.run(payload, ctx);\n    if (left instanceof Promise) {\n      return left.then((left2) => handlePipeResult(left2, def, ctx));\n    }\n    return handlePipeResult(left, def, ctx);\n  };\n});\nfunction handlePipeResult(left, def, ctx) {\n  if (aborted(left)) {\n    return left;\n  }\n  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);\n}\nvar $ZodReadonly = /* @__PURE__ */ $constructor(\"$ZodReadonly\", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n  defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(handleReadonlyResult);\n    }\n    return handleReadonlyResult(result);\n  };\n});\nfunction handleReadonlyResult(payload) {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}\nvar $ZodCustom = /* @__PURE__ */ $constructor(\"$ZodCustom\", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _) => {\n    return payload;\n  };\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const r = def.fn(input);\n    if (r instanceof Promise) {\n      return r.then((r2) => handleRefineResult(r2, payload, input, inst));\n    }\n    handleRefineResult(r, payload, input, inst);\n    return;\n  };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n  if (!result) {\n    const _iss = {\n      code: \"custom\",\n      input,\n      inst,\n      // incorporates params.error into issue reporting\n      path: [...inst._zod.def.path ?? []],\n      // incorporates params.error into issue reporting\n      continue: !inst._zod.def.abort\n      // params: inst._zod.def.params,\n    };\n    if (inst._zod.def.params)\n      _iss.params = inst._zod.def.params;\n    payload.issues.push(issue(_iss));\n  }\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/registries.js\nvar $output = Symbol(\"ZodOutput\");\nvar $input = Symbol(\"ZodInput\");\nvar $ZodRegistry = class {\n  constructor() {\n    this._map = /* @__PURE__ */ new Map();\n    this._idmap = /* @__PURE__ */ new Map();\n  }\n  add(schema, ..._meta) {\n    const meta = _meta[0];\n    this._map.set(schema, meta);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      if (this._idmap.has(meta.id)) {\n        throw new Error(`ID ${meta.id} already exists in the registry`);\n      }\n      this._idmap.set(meta.id, schema);\n    }\n    return this;\n  }\n  clear() {\n    this._map = /* @__PURE__ */ new Map();\n    this._idmap = /* @__PURE__ */ new Map();\n    return this;\n  }\n  remove(schema) {\n    const meta = this._map.get(schema);\n    if (meta && typeof meta === \"object\" && \"id\" in meta) {\n      this._idmap.delete(meta.id);\n    }\n    this._map.delete(schema);\n    return this;\n  }\n  get(schema) {\n    const p = schema._zod.parent;\n    if (p) {\n      const pm = { ...this.get(p) ?? {} };\n      delete pm.id;\n      return { ...pm, ...this._map.get(schema) };\n    }\n    return this._map.get(schema);\n  }\n  has(schema) {\n    return this._map.has(schema);\n  }\n};\nfunction registry() {\n  return new $ZodRegistry();\n}\nvar globalRegistry = /* @__PURE__ */ registry();\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/api.js\nfunction _unknown(Class2) {\n  return new Class2({\n    type: \"unknown\"\n  });\n}\nfunction _never(Class2, params) {\n  return new Class2({\n    type: \"never\",\n    ...normalizeParams(params)\n  });\n}\nfunction _maxLength(maximum, params) {\n  const ch = new $ZodCheckMaxLength({\n    check: \"max_length\",\n    ...normalizeParams(params),\n    maximum\n  });\n  return ch;\n}\nfunction _minLength(minimum, params) {\n  return new $ZodCheckMinLength({\n    check: \"min_length\",\n    ...normalizeParams(params),\n    minimum\n  });\n}\nfunction _length(length, params) {\n  return new $ZodCheckLengthEquals({\n    check: \"length_equals\",\n    ...normalizeParams(params),\n    length\n  });\n}\nfunction _overwrite(tx) {\n  return new $ZodCheckOverwrite({\n    check: \"overwrite\",\n    tx\n  });\n}\nfunction _array(Class2, element, params) {\n  return new Class2({\n    type: \"array\",\n    element,\n    // get element() {\n    //   return element;\n    // },\n    ...normalizeParams(params)\n  });\n}\nfunction _refine(Class2, fn, _params) {\n  const schema = new Class2({\n    type: \"custom\",\n    check: \"custom\",\n    fn,\n    ...normalizeParams(_params)\n  });\n  return schema;\n}\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/errors.js\nvar initializer2 = (inst, issues) => {\n  $ZodError.init(inst, issues);\n  inst.name = \"ZodError\";\n  Object.defineProperties(inst, {\n    format: {\n      value: (mapper) => formatError(inst, mapper)\n      // enumerable: false,\n    },\n    flatten: {\n      value: (mapper) => flattenError(inst, mapper)\n      // enumerable: false,\n    },\n    addIssue: {\n      value: (issue2) => inst.issues.push(issue2)\n      // enumerable: false,\n    },\n    addIssues: {\n      value: (issues2) => inst.issues.push(...issues2)\n      // enumerable: false,\n    },\n    isEmpty: {\n      get() {\n        return inst.issues.length === 0;\n      }\n      // enumerable: false,\n    }\n  });\n};\nvar ZodError = $constructor(\"ZodError\", initializer2);\nvar ZodRealError = $constructor(\"ZodError\", initializer2, {\n  Parent: Error\n});\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/parse.js\nvar parse = /* @__PURE__ */ _parse(ZodRealError);\nvar parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);\nvar safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);\nvar safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);\n\n// node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/schemas.js\nvar ZodType = /* @__PURE__ */ $constructor(\"ZodType\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst.def = def;\n  Object.defineProperty(inst, \"_def\", { value: def });\n  inst.check = (...checks) => {\n    return inst.clone(\n      {\n        ...def,\n        checks: [\n          ...def.checks ?? [],\n          ...checks.map((ch) => typeof ch === \"function\" ? { _zod: { check: ch, def: { check: \"custom\" }, onattach: [] } } : ch)\n        ]\n      }\n      // { parent: true }\n    );\n  };\n  inst.clone = (def2, params) => clone(inst, def2, params);\n  inst.brand = () => inst;\n  inst.register = (reg, meta) => {\n    reg.add(inst, meta);\n    return inst;\n  };\n  inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });\n  inst.safeParse = (data, params) => safeParse2(inst, data, params);\n  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });\n  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);\n  inst.spa = inst.safeParseAsync;\n  inst.refine = (check2, params) => inst.check(refine(check2, params));\n  inst.superRefine = (refinement) => inst.check(superRefine(refinement));\n  inst.overwrite = (fn) => inst.check(_overwrite(fn));\n  inst.optional = () => optional(inst);\n  inst.nullable = () => nullable(inst);\n  inst.nullish = () => optional(nullable(inst));\n  inst.nonoptional = (params) => nonoptional(inst, params);\n  inst.array = () => array(inst);\n  inst.or = (arg) => union([inst, arg]);\n  inst.and = (arg) => intersection(inst, arg);\n  inst.transform = (tx) => pipe(inst, transform(tx));\n  inst.default = (def2) => _default(inst, def2);\n  inst.prefault = (def2) => prefault(inst, def2);\n  inst.catch = (params) => _catch(inst, params);\n  inst.pipe = (target) => pipe(inst, target);\n  inst.readonly = () => readonly(inst);\n  inst.describe = (description) => {\n    const cl = inst.clone();\n    globalRegistry.add(cl, { description });\n    return cl;\n  };\n  Object.defineProperty(inst, \"description\", {\n    get() {\n      return globalRegistry.get(inst)?.description;\n    },\n    configurable: true\n  });\n  inst.meta = (...args) => {\n    if (args.length === 0) {\n      return globalRegistry.get(inst);\n    }\n    const cl = inst.clone();\n    globalRegistry.add(cl, args[0]);\n    return cl;\n  };\n  inst.isOptional = () => inst.safeParse(void 0).success;\n  inst.isNullable = () => inst.safeParse(null).success;\n  return inst;\n});\nvar ZodUnknown = /* @__PURE__ */ $constructor(\"ZodUnknown\", (inst, def) => {\n  $ZodUnknown.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction unknown() {\n  return _unknown(ZodUnknown);\n}\nvar ZodNever = /* @__PURE__ */ $constructor(\"ZodNever\", (inst, def) => {\n  $ZodNever.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction never(params) {\n  return _never(ZodNever, params);\n}\nvar ZodArray = /* @__PURE__ */ $constructor(\"ZodArray\", (inst, def) => {\n  $ZodArray.init(inst, def);\n  ZodType.init(inst, def);\n  inst.element = def.element;\n  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));\n  inst.nonempty = (params) => inst.check(_minLength(1, params));\n  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));\n  inst.length = (len, params) => inst.check(_length(len, params));\n  inst.unwrap = () => inst.element;\n});\nfunction array(element, params) {\n  return _array(ZodArray, element, params);\n}\nvar ZodObject = /* @__PURE__ */ $constructor(\"ZodObject\", (inst, def) => {\n  $ZodObject.init(inst, def);\n  ZodType.init(inst, def);\n  util_exports.defineLazy(inst, \"shape\", () => def.shape);\n  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));\n  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });\n  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });\n  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });\n  inst.extend = (incoming) => {\n    return util_exports.extend(inst, incoming);\n  };\n  inst.merge = (other) => util_exports.merge(inst, other);\n  inst.pick = (mask) => util_exports.pick(inst, mask);\n  inst.omit = (mask) => util_exports.omit(inst, mask);\n  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);\n  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);\n});\nvar ZodUnion = /* @__PURE__ */ $constructor(\"ZodUnion\", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  ZodType.init(inst, def);\n  inst.options = def.options;\n});\nfunction union(options, params) {\n  return new ZodUnion({\n    type: \"union\",\n    options,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodIntersection = /* @__PURE__ */ $constructor(\"ZodIntersection\", (inst, def) => {\n  $ZodIntersection.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction intersection(left, right) {\n  return new ZodIntersection({\n    type: \"intersection\",\n    left,\n    right\n  });\n}\nvar ZodEnum = /* @__PURE__ */ $constructor(\"ZodEnum\", (inst, def) => {\n  $ZodEnum.init(inst, def);\n  ZodType.init(inst, def);\n  inst.enum = def.entries;\n  inst.options = Object.values(def.entries);\n  const keys = new Set(Object.keys(def.entries));\n  inst.extract = (values, params) => {\n    const newEntries = {};\n    for (const value of values) {\n      if (keys.has(value)) {\n        newEntries[value] = def.entries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n  inst.exclude = (values, params) => {\n    const newEntries = { ...def.entries };\n    for (const value of values) {\n      if (keys.has(value)) {\n        delete newEntries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n});\nfunction _enum(values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n  return new ZodEnum({\n    type: \"enum\",\n    entries,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodTransform = /* @__PURE__ */ $constructor(\"ZodTransform\", (inst, def) => {\n  $ZodTransform.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === \"string\") {\n        payload.issues.push(util_exports.issue(issue2, payload.value, def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = \"custom\");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = inst);\n        _issue.continue ?? (_issue.continue = true);\n        payload.issues.push(util_exports.issue(_issue));\n      }\n    };\n    const output = def.transform(payload.value, payload);\n    if (output instanceof Promise) {\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    payload.value = output;\n    return payload;\n  };\n});\nfunction transform(fn) {\n  return new ZodTransform({\n    type: \"transform\",\n    transform: fn\n  });\n}\nvar ZodOptional = /* @__PURE__ */ $constructor(\"ZodOptional\", (inst, def) => {\n  $ZodOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction optional(innerType) {\n  return new ZodOptional({\n    type: \"optional\",\n    innerType\n  });\n}\nvar ZodNullable = /* @__PURE__ */ $constructor(\"ZodNullable\", (inst, def) => {\n  $ZodNullable.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nullable(innerType) {\n  return new ZodNullable({\n    type: \"nullable\",\n    innerType\n  });\n}\nvar ZodDefault = /* @__PURE__ */ $constructor(\"ZodDefault\", (inst, def) => {\n  $ZodDefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeDefault = inst.unwrap;\n});\nfunction _default(innerType, defaultValue) {\n  return new ZodDefault({\n    type: \"default\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodPrefault = /* @__PURE__ */ $constructor(\"ZodPrefault\", (inst, def) => {\n  $ZodPrefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction prefault(innerType, defaultValue) {\n  return new ZodPrefault({\n    type: \"prefault\",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n    }\n  });\n}\nvar ZodNonOptional = /* @__PURE__ */ $constructor(\"ZodNonOptional\", (inst, def) => {\n  $ZodNonOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nonoptional(innerType, params) {\n  return new ZodNonOptional({\n    type: \"nonoptional\",\n    innerType,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodCatch = /* @__PURE__ */ $constructor(\"ZodCatch\", (inst, def) => {\n  $ZodCatch.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeCatch = inst.unwrap;\n});\nfunction _catch(innerType, catchValue) {\n  return new ZodCatch({\n    type: \"catch\",\n    innerType,\n    catchValue: typeof catchValue === \"function\" ? catchValue : () => catchValue\n  });\n}\nvar ZodPipe = /* @__PURE__ */ $constructor(\"ZodPipe\", (inst, def) => {\n  $ZodPipe.init(inst, def);\n  ZodType.init(inst, def);\n  inst.in = def.in;\n  inst.out = def.out;\n});\nfunction pipe(in_, out) {\n  return new ZodPipe({\n    type: \"pipe\",\n    in: in_,\n    out\n    // ...util.normalizeParams(params),\n  });\n}\nvar ZodReadonly = /* @__PURE__ */ $constructor(\"ZodReadonly\", (inst, def) => {\n  $ZodReadonly.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction readonly(innerType) {\n  return new ZodReadonly({\n    type: \"readonly\",\n    innerType\n  });\n}\nvar ZodCustom = /* @__PURE__ */ $constructor(\"ZodCustom\", (inst, def) => {\n  $ZodCustom.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction check(fn) {\n  const ch = new $ZodCheck({\n    check: \"custom\"\n    // ...util.normalizeParams(params),\n  });\n  ch._zod.check = fn;\n  return ch;\n}\nfunction refine(fn, _params = {}) {\n  return _refine(ZodCustom, fn, _params);\n}\nfunction superRefine(fn) {\n  const ch = check((payload) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === \"string\") {\n        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = \"custom\");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = ch);\n        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);\n        payload.issues.push(util_exports.issue(_issue));\n      }\n    };\n    return fn(payload.value, payload);\n  });\n  return ch;\n}\n\n// src/openapi.ts\nvar paths = {};\nfunction getTypeFromZodType(zodType) {\n  switch (zodType.constructor.name) {\n    case \"ZodString\":\n      return \"string\";\n    case \"ZodNumber\":\n      return \"number\";\n    case \"ZodBoolean\":\n      return \"boolean\";\n    case \"ZodObject\":\n      return \"object\";\n    case \"ZodArray\":\n      return \"array\";\n    default:\n      return \"string\";\n  }\n}\nfunction getParameters(options) {\n  const parameters = [];\n  if (options.metadata?.openapi?.parameters) {\n    parameters.push(...options.metadata.openapi.parameters);\n    return parameters;\n  }\n  if (options.query instanceof ZodObject) {\n    Object.entries(options.query.shape).forEach(([key, value]) => {\n      if (value instanceof ZodObject) {\n        parameters.push({\n          name: key,\n          in: \"query\",\n          schema: {\n            type: getTypeFromZodType(value),\n            ...\"minLength\" in value && value.minLength ? {\n              minLength: value.minLength\n            } : {},\n            description: value.description\n          }\n        });\n      }\n    });\n  }\n  return parameters;\n}\nfunction getRequestBody(options) {\n  if (options.metadata?.openapi?.requestBody) {\n    return options.metadata.openapi.requestBody;\n  }\n  if (!options.body) return void 0;\n  if (options.body instanceof ZodObject || options.body instanceof ZodOptional) {\n    const shape = options.body.shape;\n    if (!shape) return void 0;\n    const properties = {};\n    const required2 = [];\n    Object.entries(shape).forEach(([key, value]) => {\n      if (value instanceof ZodObject) {\n        properties[key] = {\n          type: getTypeFromZodType(value),\n          description: value.description\n        };\n        if (!(value instanceof ZodOptional)) {\n          required2.push(key);\n        }\n      }\n    });\n    return {\n      required: options.body instanceof ZodOptional ? false : options.body ? true : false,\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties,\n            required: required2\n          }\n        }\n      }\n    };\n  }\n  return void 0;\n}\nfunction getResponse(responses) {\n  return {\n    \"400\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            },\n            required: [\"message\"]\n          }\n        }\n      },\n      description: \"Bad Request. Usually due to missing parameters, or invalid parameters.\"\n    },\n    \"401\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            },\n            required: [\"message\"]\n          }\n        }\n      },\n      description: \"Unauthorized. Due to missing or invalid authentication.\"\n    },\n    \"403\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Forbidden. You do not have permission to access this resource or to perform this action.\"\n    },\n    \"404\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Not Found. The requested resource was not found.\"\n    },\n    \"429\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Too Many Requests. You have exceeded the rate limit. Try again later.\"\n    },\n    \"500\": {\n      content: {\n        \"application/json\": {\n          schema: {\n            type: \"object\",\n            properties: {\n              message: {\n                type: \"string\"\n              }\n            }\n          }\n        }\n      },\n      description: \"Internal Server Error. This is a problem with the server that you cannot fix.\"\n    },\n    ...responses\n  };\n}\nasync function generator(endpoints, config2) {\n  const components = {\n    schemas: {}\n  };\n  Object.entries(endpoints).forEach(([_, value]) => {\n    const options = value.options;\n    if (options.metadata?.SERVER_ONLY) return;\n    if (options.method === \"GET\") {\n      paths[value.path] = {\n        get: {\n          tags: [\"Default\", ...options.metadata?.openapi?.tags || []],\n          description: options.metadata?.openapi?.description,\n          operationId: options.metadata?.openapi?.operationId,\n          security: [\n            {\n              bearerAuth: []\n            }\n          ],\n          parameters: getParameters(options),\n          responses: getResponse(options.metadata?.openapi?.responses)\n        }\n      };\n    }\n    if (options.method === \"POST\") {\n      const body = getRequestBody(options);\n      paths[value.path] = {\n        post: {\n          tags: [\"Default\", ...options.metadata?.openapi?.tags || []],\n          description: options.metadata?.openapi?.description,\n          operationId: options.metadata?.openapi?.operationId,\n          security: [\n            {\n              bearerAuth: []\n            }\n          ],\n          parameters: getParameters(options),\n          ...body ? { requestBody: body } : {\n            requestBody: {\n              //set body none\n              content: {\n                \"application/json\": {\n                  schema: {\n                    type: \"object\",\n                    properties: {}\n                  }\n                }\n              }\n            }\n          },\n          responses: getResponse(options.metadata?.openapi?.responses)\n        }\n      };\n    }\n  });\n  const res = {\n    openapi: \"3.1.1\",\n    info: {\n      title: \"Better Auth\",\n      description: \"API Reference for your Better Auth Instance\",\n      version: \"1.1.0\"\n    },\n    components,\n    security: [\n      {\n        apiKeyCookie: []\n      }\n    ],\n    servers: [\n      {\n        url: config2?.url\n      }\n    ],\n    tags: [\n      {\n        name: \"Default\",\n        description: \"Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin.\"\n      }\n    ],\n    paths\n  };\n  return res;\n}\nvar getHTML = (apiReference, config2) => `<!doctype html>\n<html>\n  <head>\n    <title>Scalar API Reference</title>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <script\n      id=\"api-reference\"\n      type=\"application/json\">\n    ${JSON.stringify(apiReference)}\n    </script>\n\t <script>\n      var configuration = {\n\t  \tfavicon: ${config2?.logo ? `data:image/svg+xml;utf8,${encodeURIComponent(config2.logo)}` : void 0} ,\n\t   \ttheme: ${config2?.theme || \"saturn\"},\n        metaData: {\n\t\t\ttitle: ${config2?.title || \"Open API Reference\"},\n\t\t\tdescription: ${config2?.description || \"Better Call Open API\"},\n\t\t}\n      }\n      document.getElementById('api-reference').dataset.configuration =\n        JSON.stringify(configuration)\n    </script>\n\t  <script src=\"https://cdn.jsdelivr.net/npm/@scalar/api-reference\"></script>\n  </body>\n</html>`;\n\n// src/router.ts\nvar createRouter = (endpoints, config2) => {\n  if (!config2?.openapi?.disabled) {\n    const openapi = {\n      path: \"/api/reference\",\n      ...config2?.openapi\n    };\n    endpoints[\"openapi\"] = createEndpoint2(\n      openapi.path,\n      {\n        method: \"GET\"\n      },\n      async (c) => {\n        const schema = await generator(endpoints);\n        return new Response(getHTML(schema, openapi.scalar), {\n          headers: {\n            \"Content-Type\": \"text/html\"\n          }\n        });\n      }\n    );\n  }\n  const router = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.createRouter)();\n  const middlewareRouter = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.createRouter)();\n  for (const endpoint of Object.values(endpoints)) {\n    if (!endpoint.options) {\n      continue;\n    }\n    if (endpoint.options?.metadata?.SERVER_ONLY) continue;\n    const methods = Array.isArray(endpoint.options?.method) ? endpoint.options.method : [endpoint.options?.method];\n    for (const method of methods) {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_1__.addRoute)(router, method, endpoint.path, endpoint);\n    }\n  }\n  if (config2?.routerMiddleware?.length) {\n    for (const { path, middleware } of config2.routerMiddleware) {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_1__.addRoute)(middlewareRouter, \"*\", path, middleware);\n    }\n  }\n  const processRequest = async (request) => {\n    const url = new URL(request.url);\n    const path = config2?.basePath ? url.pathname.split(config2.basePath).reduce((acc, curr, index) => {\n      if (index !== 0) {\n        if (index > 1) {\n          acc.push(`${config2.basePath}${curr}`);\n        } else {\n          acc.push(curr);\n        }\n      }\n      return acc;\n    }, []).join(\"\") : url.pathname;\n    if (!path?.length) {\n      return new Response(null, { status: 404, statusText: \"Not Found\" });\n    }\n    const route = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.findRoute)(router, request.method, path);\n    if (!route?.data) {\n      return new Response(null, { status: 404, statusText: \"Not Found\" });\n    }\n    const query = {};\n    url.searchParams.forEach((value, key) => {\n      if (key in query) {\n        if (Array.isArray(query[key])) {\n          query[key].push(value);\n        } else {\n          query[key] = [query[key], value];\n        }\n      } else {\n        query[key] = value;\n      }\n    });\n    const handler = route.data;\n    const context = {\n      path,\n      method: request.method,\n      headers: request.headers,\n      params: route.params ? JSON.parse(JSON.stringify(route.params)) : {},\n      request,\n      body: handler.options.disableBody ? void 0 : await getBody(handler.options.cloneRequest ? request.clone() : request),\n      query,\n      _flag: \"router\",\n      asResponse: true,\n      context: config2?.routerContext\n    };\n    try {\n      const middlewareRoutes = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.findAllRoutes)(middlewareRouter, \"*\", path);\n      if (middlewareRoutes?.length) {\n        for (const { data: middleware, params } of middlewareRoutes) {\n          const res = await middleware({\n            ...context,\n            params,\n            asResponse: false\n          });\n          if (res instanceof Response) return res;\n        }\n      }\n      const response = await handler(context);\n      return response;\n    } catch (error) {\n      if (isAPIError(error)) {\n        return toResponse(error);\n      }\n      console.error(`# SERVER_ERROR: `, error);\n      return new Response(null, {\n        status: 500,\n        statusText: \"Internal Server Error\"\n      });\n    }\n  };\n  return {\n    handler: async (request) => {\n      const onReq = await config2?.onRequest?.(request);\n      if (onReq instanceof Response) {\n        return onReq;\n      }\n      const req = onReq instanceof Request ? onReq : request;\n      const res = await processRequest(req);\n      const onRes = await config2?.onResponse?.(res);\n      if (onRes instanceof Response) {\n        return onRes;\n      }\n      return res;\n    },\n    endpoints\n  };\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmV0dGVyLWNhbGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNILHFDQUFxQyxhQUFhO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FB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Q0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUNBQXFDLDJCQUEyQjtBQUNoRSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyQkFBMkI7QUFDaEUsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3Q0FBd0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0MsT0FBTyxpQ0FBaUMsWUFBWTtBQUN2RyxjQUFjLDJCQUEyQjtBQUN6QztBQUNBLFlBQVksdUNBQXVDO0FBQ25ELGtCQUFrQiwrQ0FBK0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0RBQWdCO0FBQ2pDLDJCQUEyQixrREFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhDQUFRO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQyxNQUFNLDhDQUFRO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCLEVBQUUsS0FBSztBQUM5QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0Msc0NBQXNDO0FBQ3hFO0FBQ0Esa0JBQWtCLCtDQUFTO0FBQzNCO0FBQ0Esa0NBQWtDLHNDQUFzQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtREFBYTtBQUM1QztBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBaUJFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYW1hYW5cXE9uZURyaXZlXFxEZXNrdG9wXFxLYW5kaWRfMlxcTmV3IGZvbGRlciAoMilcXG5vZGVfbW9kdWxlc1xcYmV0dGVyLWNhbGxcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9lcnJvci50c1xuZnVuY3Rpb24gaXNFcnJvclN0YWNrVHJhY2VMaW1pdFdyaXRhYmxlKCkge1xuICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFcnJvciwgXCJzdGFja1RyYWNlTGltaXRcIik7XG4gIGlmIChkZXNjID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShFcnJvcik7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZXNjLCBcIndyaXRhYmxlXCIpID8gZGVzYy53cml0YWJsZSA6IGRlc2Muc2V0ICE9PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBoaWRlSW50ZXJuYWxTdGFja0ZyYW1lcyhzdGFjaykge1xuICBjb25zdCBsaW5lcyA9IHN0YWNrLnNwbGl0KFwiXFxuICAgIGF0IFwiKTtcbiAgaWYgKGxpbmVzLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9XG4gIGxpbmVzLnNwbGljZSgxLCAxKTtcbiAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG4gICAgYXQgXCIpO1xufVxuZnVuY3Rpb24gbWFrZUVycm9yRm9ySGlkZVN0YWNrRnJhbWUoQmFzZSwgY2xhenopIHtcbiAgY2xhc3MgSGlkZVN0YWNrRnJhbWVzRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICAjaGlkZGVuU3RhY2s7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgaWYgKGlzRXJyb3JTdGFja1RyYWNlTGltaXRXcml0YWJsZSgpKSB7XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0O1xuICAgICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwO1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gbGltaXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgdGhpcy4jaGlkZGVuU3RhY2sgPSBoaWRlSW50ZXJuYWxTdGFja0ZyYW1lcyhzdGFjay5yZXBsYWNlKC9eRXJyb3IvLCB0aGlzLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlIGBnZXR0ZXJgIGhlcmUgdG8gYXZvaWQgdGhlIHN0YWNrIHRyYWNlIGJlaW5nIGNhcHR1cmVkIGJ5IGxvZ2dlcnNcbiAgICBnZXQgZXJyb3JTdGFjaygpIHtcbiAgICAgIHJldHVybiB0aGlzLiNoaWRkZW5TdGFjaztcbiAgICB9XG4gICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIHdwdCB0ZXN0cyB0aGF0IGV4cGVjdCB0aGF0IHRoZSBlcnJvclxuICAgIC8vIGNvbnN0cnVjdG9yIGhhcyBhIGBuYW1lYCBwcm9wZXJ0eSBvZiB0aGUgYmFzZSBjbGFzcy5cbiAgICBnZXQgW1wiY29uc3RydWN0b3JcIl0oKSB7XG4gICAgICByZXR1cm4gY2xheno7XG4gICAgfVxuICB9XG4gIHJldHVybiBIaWRlU3RhY2tGcmFtZXNFcnJvcjtcbn1cbnZhciBfc3RhdHVzQ29kZSA9IHtcbiAgT0s6IDIwMCxcbiAgQ1JFQVRFRDogMjAxLFxuICBBQ0NFUFRFRDogMjAyLFxuICBOT19DT05URU5UOiAyMDQsXG4gIE1VTFRJUExFX0NIT0lDRVM6IDMwMCxcbiAgTU9WRURfUEVSTUFORU5UTFk6IDMwMSxcbiAgRk9VTkQ6IDMwMixcbiAgU0VFX09USEVSOiAzMDMsXG4gIE5PVF9NT0RJRklFRDogMzA0LFxuICBURU1QT1JBUllfUkVESVJFQ1Q6IDMwNyxcbiAgQkFEX1JFUVVFU1Q6IDQwMCxcbiAgVU5BVVRIT1JJWkVEOiA0MDEsXG4gIFBBWU1FTlRfUkVRVUlSRUQ6IDQwMixcbiAgRk9SQklEREVOOiA0MDMsXG4gIE5PVF9GT1VORDogNDA0LFxuICBNRVRIT0RfTk9UX0FMTE9XRUQ6IDQwNSxcbiAgTk9UX0FDQ0VQVEFCTEU6IDQwNixcbiAgUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQ6IDQwNyxcbiAgUkVRVUVTVF9USU1FT1VUOiA0MDgsXG4gIENPTkZMSUNUOiA0MDksXG4gIEdPTkU6IDQxMCxcbiAgTEVOR1RIX1JFUVVJUkVEOiA0MTEsXG4gIFBSRUNPTkRJVElPTl9GQUlMRUQ6IDQxMixcbiAgUEFZTE9BRF9UT09fTEFSR0U6IDQxMyxcbiAgVVJJX1RPT19MT05HOiA0MTQsXG4gIFVOU1VQUE9SVEVEX01FRElBX1RZUEU6IDQxNSxcbiAgUkFOR0VfTk9UX1NBVElTRklBQkxFOiA0MTYsXG4gIEVYUEVDVEFUSU9OX0ZBSUxFRDogNDE3LFxuICBcIkknTV9BX1RFQVBPVFwiOiA0MTgsXG4gIE1JU0RJUkVDVEVEX1JFUVVFU1Q6IDQyMSxcbiAgVU5QUk9DRVNTQUJMRV9FTlRJVFk6IDQyMixcbiAgTE9DS0VEOiA0MjMsXG4gIEZBSUxFRF9ERVBFTkRFTkNZOiA0MjQsXG4gIFRPT19FQVJMWTogNDI1LFxuICBVUEdSQURFX1JFUVVJUkVEOiA0MjYsXG4gIFBSRUNPTkRJVElPTl9SRVFVSVJFRDogNDI4LFxuICBUT09fTUFOWV9SRVFVRVNUUzogNDI5LFxuICBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFOiA0MzEsXG4gIFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TOiA0NTEsXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuICBOT1RfSU1QTEVNRU5URUQ6IDUwMSxcbiAgQkFEX0dBVEVXQVk6IDUwMixcbiAgU0VSVklDRV9VTkFWQUlMQUJMRTogNTAzLFxuICBHQVRFV0FZX1RJTUVPVVQ6IDUwNCxcbiAgSFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQ6IDUwNSxcbiAgVkFSSUFOVF9BTFNPX05FR09USUFURVM6IDUwNixcbiAgSU5TVUZGSUNJRU5UX1NUT1JBR0U6IDUwNyxcbiAgTE9PUF9ERVRFQ1RFRDogNTA4LFxuICBOT1RfRVhURU5ERUQ6IDUxMCxcbiAgTkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRDogNTExXG59O1xudmFyIEludGVybmFsQVBJRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzID0gXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIiwgYm9keSA9IHZvaWQgMCwgaGVhZGVycyA9IHt9LCBzdGF0dXNDb2RlID0gdHlwZW9mIHN0YXR1cyA9PT0gXCJudW1iZXJcIiA/IHN0YXR1cyA6IF9zdGF0dXNDb2RlW3N0YXR1c10pIHtcbiAgICBzdXBlcihcbiAgICAgIGJvZHk/Lm1lc3NhZ2UsXG4gICAgICBib2R5Py5jYXVzZSA/IHtcbiAgICAgICAgY2F1c2U6IGJvZHkuY2F1c2VcbiAgICAgIH0gOiB2b2lkIDBcbiAgICApO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMubmFtZSA9IFwiQVBJRXJyb3JcIjtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5ib2R5ID0gYm9keSA/IHtcbiAgICAgIGNvZGU6IGJvZHk/Lm1lc3NhZ2U/LnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvIC9nLCBcIl9cIikucmVwbGFjZSgvW15BLVowLTlfXS9nLCBcIlwiKSxcbiAgICAgIC4uLmJvZHlcbiAgICB9IDogdm9pZCAwO1xuICB9XG59O1xudmFyIEFQSUVycm9yID0gbWFrZUVycm9yRm9ySGlkZVN0YWNrRnJhbWUoSW50ZXJuYWxBUElFcnJvciwgRXJyb3IpO1xuXG4vLyBzcmMvdXRpbHMudHNcbmFzeW5jIGZ1bmN0aW9uIGdldEJvZHkocmVxdWVzdCkge1xuICBjb25zdCBjb250ZW50VHlwZSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIjtcbiAgaWYgKCFyZXF1ZXN0LmJvZHkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpKSB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9ybURhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKSkge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvcm1EYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJ0ZXh0L3BsYWluXCIpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSkge1xuICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LmFycmF5QnVmZmVyKCk7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vcGRmXCIpIHx8IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiaW1hZ2UvXCIpIHx8IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwidmlkZW8vXCIpKSB7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlcXVlc3QuYmxvYigpO1xuICAgIHJldHVybiBibG9iO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3N0cmVhbVwiKSB8fCByZXF1ZXN0LmJvZHkgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiByZXF1ZXN0LmJvZHk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHJlcXVlc3QudGV4dCgpO1xufVxuZnVuY3Rpb24gaXNBUElFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBBUElFcnJvciB8fCBlcnJvcj8ubmFtZSA9PT0gXCJBUElFcnJvclwiO1xufVxuZnVuY3Rpb24gdHJ5RGVjb2RlKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBzdHIuaW5jbHVkZXMoXCIlXCIpID8gZGVjb2RlVVJJQ29tcG9uZW50KHN0cikgOiBzdHI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuLy8gc3JjL3RvLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBpc0pTT05TZXJpYWxpemFibGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHQgPT09IFwic3RyaW5nXCIgfHwgdCA9PT0gXCJudW1iZXJcIiB8fCB0ID09PSBcImJvb2xlYW5cIiB8fCB0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHQgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlLmJ1ZmZlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IubmFtZSA9PT0gXCJPYmplY3RcIiB8fCB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBzYWZlU3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gIGxldCBpZCA9IDA7XG4gIGNvbnN0IHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3Qgc2FmZVJlcGxhY2VyID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKHNlZW4uaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYFtDaXJjdWxhciByZWYtJHtzZWVuLmdldCh2YWx1ZSl9XWA7XG4gICAgICB9XG4gICAgICBzZWVuLnNldCh2YWx1ZSwgaWQrKyk7XG4gICAgfVxuICAgIGlmIChyZXBsYWNlcikge1xuICAgICAgcmV0dXJuIHJlcGxhY2VyKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIHNhZmVSZXBsYWNlciwgc3BhY2UpO1xufVxuZnVuY3Rpb24gaXNKU09OUmVzcG9uc2UodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFwiX2ZsYWdcIiBpbiB2YWx1ZSAmJiB2YWx1ZS5fZmxhZyA9PT0gXCJqc29uXCI7XG59XG5mdW5jdGlvbiB0b1Jlc3BvbnNlKGRhdGEsIGluaXQpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgIGlmIChpbml0Py5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaW5pdC5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgZGF0YS5oZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBjb25zdCBpc0pTT04gPSBpc0pTT05SZXNwb25zZShkYXRhKTtcbiAgaWYgKGlzSlNPTikge1xuICAgIGNvbnN0IGJvZHkyID0gZGF0YS5ib2R5O1xuICAgIGNvbnN0IHJvdXRlclJlc3BvbnNlID0gZGF0YS5yb3V0ZXJSZXNwb25zZTtcbiAgICBpZiAocm91dGVyUmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHJvdXRlclJlc3BvbnNlO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzMiA9IG5ldyBIZWFkZXJzKHtcbiAgICAgIC4uLnJvdXRlclJlc3BvbnNlPy5oZWFkZXJzLFxuICAgICAgLi4uZGF0YS5oZWFkZXJzLFxuICAgICAgLi4uaW5pdD8uaGVhZGVycyxcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShib2R5MiksIHtcbiAgICAgIC4uLnJvdXRlclJlc3BvbnNlLFxuICAgICAgaGVhZGVyczogaGVhZGVyczIsXG4gICAgICBzdGF0dXM6IGRhdGEuc3RhdHVzID8/IGluaXQ/LnN0YXR1cyA/PyByb3V0ZXJSZXNwb25zZT8uc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdD8uc3RhdHVzVGV4dCA/PyByb3V0ZXJSZXNwb25zZT8uc3RhdHVzVGV4dFxuICAgIH0pO1xuICB9XG4gIGlmIChpc0FQSUVycm9yKGRhdGEpKSB7XG4gICAgcmV0dXJuIHRvUmVzcG9uc2UoZGF0YS5ib2R5LCB7XG4gICAgICBzdGF0dXM6IGluaXQ/LnN0YXR1cyA/PyBkYXRhLnN0YXR1c0NvZGUsXG4gICAgICBzdGF0dXNUZXh0OiBkYXRhLnN0YXR1cy50b1N0cmluZygpLFxuICAgICAgaGVhZGVyczogaW5pdD8uaGVhZGVycyB8fCBkYXRhLmhlYWRlcnNcbiAgICB9KTtcbiAgfVxuICBsZXQgYm9keSA9IGRhdGE7XG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdD8uaGVhZGVycyk7XG4gIGlmICghZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkobnVsbCk7XG4gICAgfVxuICAgIGhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGJvZHkgPSBkYXRhO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC9wbGFpblwiKTtcbiAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgYm9keSA9IGRhdGE7XG4gICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICBib2R5ID0gZGF0YTtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBkYXRhLnR5cGUgfHwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgYm9keSA9IGRhdGE7XG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIGJvZHkgPSBkYXRhO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIGJvZHkgPSBkYXRhO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpO1xuICB9IGVsc2UgaWYgKGlzSlNPTlNlcmlhbGl6YWJsZShkYXRhKSkge1xuICAgIGJvZHkgPSBzYWZlU3RyaW5naWZ5KGRhdGEpO1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgfVxuICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHtcbiAgICAuLi5pbml0LFxuICAgIGhlYWRlcnNcbiAgfSk7XG59XG5cbi8vIHNyYy92YWxpZGF0b3IudHNcbmFzeW5jIGZ1bmN0aW9uIHJ1blZhbGlkYXRpb24ob3B0aW9ucywgY29udGV4dCA9IHt9KSB7XG4gIGxldCByZXF1ZXN0ID0ge1xuICAgIGJvZHk6IGNvbnRleHQuYm9keSxcbiAgICBxdWVyeTogY29udGV4dC5xdWVyeVxuICB9O1xuICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3B0aW9ucy5ib2R5W1wifnN0YW5kYXJkXCJdLnZhbGlkYXRlKGNvbnRleHQuYm9keSk7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIGVycm9yOiBmcm9tRXJyb3IocmVzdWx0Lmlzc3VlcywgXCJib2R5XCIpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXF1ZXN0LmJvZHkgPSByZXN1bHQudmFsdWU7XG4gIH1cbiAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvcHRpb25zLnF1ZXJ5W1wifnN0YW5kYXJkXCJdLnZhbGlkYXRlKGNvbnRleHQucXVlcnkpO1xuICAgIGlmIChyZXN1bHQuaXNzdWVzKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICBlcnJvcjogZnJvbUVycm9yKHJlc3VsdC5pc3N1ZXMsIFwicXVlcnlcIilcbiAgICAgIH07XG4gICAgfVxuICAgIHJlcXVlc3QucXVlcnkgPSByZXN1bHQudmFsdWU7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVxdWlyZUhlYWRlcnMgJiYgIWNvbnRleHQuaGVhZGVycykge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgZXJyb3I6IHsgbWVzc2FnZTogXCJIZWFkZXJzIGlzIHJlcXVpcmVkXCIgfVxuICAgIH07XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVxdWlyZVJlcXVlc3QgJiYgIWNvbnRleHQucmVxdWVzdCkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgZXJyb3I6IHsgbWVzc2FnZTogXCJSZXF1ZXN0IGlzIHJlcXVpcmVkXCIgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRhOiByZXF1ZXN0LFxuICAgIGVycm9yOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiBmcm9tRXJyb3IoZXJyb3IsIHZhbGlkYXRpbmcpIHtcbiAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGlzc3VlMiBvZiBlcnJvcikge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBpc3N1ZTIubWVzc2FnZTtcbiAgICBlcnJvck1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlOiBgSW52YWxpZCAke3ZhbGlkYXRpbmd9IHBhcmFtZXRlcnNgXG4gIH07XG59XG5cbi8vIHNyYy9jcnlwdG8udHNcbmltcG9ydCB7IHN1YnRsZSB9IGZyb20gXCJ1bmNyeXB0b1wiO1xudmFyIGFsZ29yaXRobSA9IHsgbmFtZTogXCJITUFDXCIsIGhhc2g6IFwiU0hBLTI1NlwiIH07XG52YXIgZ2V0Q3J5cHRvS2V5ID0gYXN5bmMgKHNlY3JldCkgPT4ge1xuICBjb25zdCBzZWNyZXRCdWYgPSB0eXBlb2Ygc2VjcmV0ID09PSBcInN0cmluZ1wiID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlY3JldCkgOiBzZWNyZXQ7XG4gIHJldHVybiBhd2FpdCBzdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIHNlY3JldEJ1ZiwgYWxnb3JpdGhtLCBmYWxzZSwgW1wic2lnblwiLCBcInZlcmlmeVwiXSk7XG59O1xudmFyIHZlcmlmeVNpZ25hdHVyZSA9IGFzeW5jIChiYXNlNjRTaWduYXR1cmUsIHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzaWduYXR1cmVCaW5TdHIgPSBhdG9iKGJhc2U2NFNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlQmluU3RyLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNpZ25hdHVyZUJpblN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2lnbmF0dXJlW2ldID0gc2lnbmF0dXJlQmluU3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwgc2VjcmV0LCBzaWduYXR1cmUsIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIG1ha2VTaWduYXR1cmUgPSBhc3luYyAodmFsdWUsIHNlY3JldCkgPT4ge1xuICBjb25zdCBrZXkgPSBhd2FpdCBnZXRDcnlwdG9LZXkoc2VjcmV0KTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc3VidGxlLnNpZ24oYWxnb3JpdGhtLm5hbWUsIGtleSwgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKSk7XG4gIHJldHVybiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSkpO1xufTtcbnZhciBzaWduQ29va2llVmFsdWUgPSBhc3luYyAodmFsdWUsIHNlY3JldCkgPT4ge1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBtYWtlU2lnbmF0dXJlKHZhbHVlLCBzZWNyZXQpO1xuICB2YWx1ZSA9IGAke3ZhbHVlfS4ke3NpZ25hdHVyZX1gO1xuICB2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8vIHNyYy9jb29raWVzLnRzXG52YXIgZ2V0Q29va2llS2V5ID0gKGtleSwgcHJlZml4KSA9PiB7XG4gIGxldCBmaW5hbEtleSA9IGtleTtcbiAgaWYgKHByZWZpeCkge1xuICAgIGlmIChwcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX1NlY3VyZS1cIiArIGtleTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gXCJob3N0XCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX0hvc3QtXCIgKyBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbEtleTtcbn07XG5mdW5jdGlvbiBwYXJzZUNvb2tpZXMoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHN0ciBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICB9XG4gIGNvbnN0IGNvb2tpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgaW5kZXggPSAwO1xuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgY29uc3QgZXFJZHggPSBzdHIuaW5kZXhPZihcIj1cIiwgaW5kZXgpO1xuICAgIGlmIChlcUlkeCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgZW5kSWR4ID0gc3RyLmluZGV4T2YoXCI7XCIsIGluZGV4KTtcbiAgICBpZiAoZW5kSWR4ID09PSAtMSkge1xuICAgICAgZW5kSWR4ID0gc3RyLmxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKGVuZElkeCA8IGVxSWR4KSB7XG4gICAgICBpbmRleCA9IHN0ci5sYXN0SW5kZXhPZihcIjtcIiwgZXFJZHggLSAxKSArIDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gc3RyLnNsaWNlKGluZGV4LCBlcUlkeCkudHJpbSgpO1xuICAgIGlmICghY29va2llcy5oYXMoa2V5KSkge1xuICAgICAgbGV0IHZhbCA9IHN0ci5zbGljZShlcUlkeCArIDEsIGVuZElkeCkudHJpbSgpO1xuICAgICAgaWYgKHZhbC5jb2RlUG9pbnRBdCgwKSA9PT0gMzQpIHtcbiAgICAgICAgdmFsID0gdmFsLnNsaWNlKDEsIC0xKTtcbiAgICAgIH1cbiAgICAgIGNvb2tpZXMuc2V0KGtleSwgdHJ5RGVjb2RlKHZhbCkpO1xuICAgIH1cbiAgICBpbmRleCA9IGVuZElkeCArIDE7XG4gIH1cbiAgcmV0dXJuIGNvb2tpZXM7XG59XG52YXIgX3NlcmlhbGl6ZSA9IChrZXksIHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBsZXQgY29va2llO1xuICBpZiAob3B0Py5wcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICBjb29raWUgPSBgJHtgX19TZWN1cmUtJHtrZXl9YH09JHt2YWx1ZX1gO1xuICB9IGVsc2UgaWYgKG9wdD8ucHJlZml4ID09PSBcImhvc3RcIikge1xuICAgIGNvb2tpZSA9IGAke2BfX0hvc3QtJHtrZXl9YH09JHt2YWx1ZX1gO1xuICB9IGVsc2Uge1xuICAgIGNvb2tpZSA9IGAke2tleX09JHt2YWx1ZX1gO1xuICB9XG4gIGlmIChrZXkuc3RhcnRzV2l0aChcIl9fU2VjdXJlLVwiKSAmJiAhb3B0LnNlY3VyZSkge1xuICAgIG9wdC5zZWN1cmUgPSB0cnVlO1xuICB9XG4gIGlmIChrZXkuc3RhcnRzV2l0aChcIl9fSG9zdC1cIikpIHtcbiAgICBpZiAoIW9wdC5zZWN1cmUpIHtcbiAgICAgIG9wdC5zZWN1cmUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0LnBhdGggIT09IFwiL1wiKSB7XG4gICAgICBvcHQucGF0aCA9IFwiL1wiO1xuICAgIH1cbiAgICBpZiAob3B0LmRvbWFpbikge1xuICAgICAgb3B0LmRvbWFpbiA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdCAmJiB0eXBlb2Ygb3B0Lm1heEFnZSA9PT0gXCJudW1iZXJcIiAmJiBvcHQubWF4QWdlID49IDApIHtcbiAgICBpZiAob3B0Lm1heEFnZSA+IDM0NTZlNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNvb2tpZXMgTWF4LUFnZSBTSE9VTEQgTk9UIGJlIGdyZWF0ZXIgdGhhbiA0MDAgZGF5cyAoMzQ1NjAwMDAgc2Vjb25kcykgaW4gZHVyYXRpb24uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvb2tpZSArPSBgOyBNYXgtQWdlPSR7TWF0aC5mbG9vcihvcHQubWF4QWdlKX1gO1xuICB9XG4gIGlmIChvcHQuZG9tYWluICYmIG9wdC5wcmVmaXggIT09IFwiaG9zdFwiKSB7XG4gICAgY29va2llICs9IGA7IERvbWFpbj0ke29wdC5kb21haW59YDtcbiAgfVxuICBpZiAob3B0LnBhdGgpIHtcbiAgICBjb29raWUgKz0gYDsgUGF0aD0ke29wdC5wYXRofWA7XG4gIH1cbiAgaWYgKG9wdC5leHBpcmVzKSB7XG4gICAgaWYgKG9wdC5leHBpcmVzLmdldFRpbWUoKSAtIERhdGUubm93KCkgPiAzNDU2ZTcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb29raWVzIEV4cGlyZXMgU0hPVUxEIE5PVCBiZSBncmVhdGVyIHRoYW4gNDAwIGRheXMgKDM0NTYwMDAwIHNlY29uZHMpIGluIHRoZSBmdXR1cmUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvb2tpZSArPSBgOyBFeHBpcmVzPSR7b3B0LmV4cGlyZXMudG9VVENTdHJpbmcoKX1gO1xuICB9XG4gIGlmIChvcHQuaHR0cE9ubHkpIHtcbiAgICBjb29raWUgKz0gXCI7IEh0dHBPbmx5XCI7XG4gIH1cbiAgaWYgKG9wdC5zZWN1cmUpIHtcbiAgICBjb29raWUgKz0gXCI7IFNlY3VyZVwiO1xuICB9XG4gIGlmIChvcHQuc2FtZVNpdGUpIHtcbiAgICBjb29raWUgKz0gYDsgU2FtZVNpdGU9JHtvcHQuc2FtZVNpdGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvcHQuc2FtZVNpdGUuc2xpY2UoMSl9YDtcbiAgfVxuICBpZiAob3B0LnBhcnRpdGlvbmVkKSB7XG4gICAgaWYgKCFvcHQuc2VjdXJlKSB7XG4gICAgICBvcHQuc2VjdXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29va2llICs9IFwiOyBQYXJ0aXRpb25lZFwiO1xuICB9XG4gIHJldHVybiBjb29raWU7XG59O1xudmFyIHNlcmlhbGl6ZUNvb2tpZSA9IChrZXksIHZhbHVlLCBvcHQpID0+IHtcbiAgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICByZXR1cm4gX3NlcmlhbGl6ZShrZXksIHZhbHVlLCBvcHQpO1xufTtcbnZhciBzZXJpYWxpemVTaWduZWRDb29raWUgPSBhc3luYyAoa2V5LCB2YWx1ZSwgc2VjcmV0LCBvcHQpID0+IHtcbiAgdmFsdWUgPSBhd2FpdCBzaWduQ29va2llVmFsdWUodmFsdWUsIHNlY3JldCk7XG4gIHJldHVybiBfc2VyaWFsaXplKGtleSwgdmFsdWUsIG9wdCk7XG59O1xuXG4vLyBzcmMvY29udGV4dC50c1xudmFyIGNyZWF0ZUludGVybmFsQ29udGV4dCA9IGFzeW5jIChjb250ZXh0LCB7XG4gIG9wdGlvbnMsXG4gIHBhdGhcbn0pID0+IHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHJ1blZhbGlkYXRpb24ob3B0aW9ucywgY29udGV4dCk7XG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IG5ldyBBUElFcnJvcig0MDAsIHtcbiAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBjb2RlOiBcIlZBTElEQVRJT05fRVJST1JcIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHJlcXVlc3RIZWFkZXJzID0gXCJoZWFkZXJzXCIgaW4gY29udGV4dCA/IGNvbnRleHQuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgPyBjb250ZXh0LmhlYWRlcnMgOiBuZXcgSGVhZGVycyhjb250ZXh0LmhlYWRlcnMpIDogXCJyZXF1ZXN0XCIgaW4gY29udGV4dCAmJiBjb250ZXh0LnJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gY29udGV4dC5yZXF1ZXN0LmhlYWRlcnMgOiBudWxsO1xuICBjb25zdCByZXF1ZXN0Q29va2llcyA9IHJlcXVlc3RIZWFkZXJzPy5nZXQoXCJjb29raWVcIik7XG4gIGNvbnN0IHBhcnNlZENvb2tpZXMgPSByZXF1ZXN0Q29va2llcyA/IHBhcnNlQ29va2llcyhyZXF1ZXN0Q29va2llcykgOiB2b2lkIDA7XG4gIGNvbnN0IGludGVybmFsQ29udGV4dCA9IHtcbiAgICAuLi5jb250ZXh0LFxuICAgIGJvZHk6IGRhdGEuYm9keSxcbiAgICBxdWVyeTogZGF0YS5xdWVyeSxcbiAgICBwYXRoOiBjb250ZXh0LnBhdGggfHwgcGF0aCxcbiAgICBjb250ZXh0OiBcImNvbnRleHRcIiBpbiBjb250ZXh0ICYmIGNvbnRleHQuY29udGV4dCA/IGNvbnRleHQuY29udGV4dCA6IHt9LFxuICAgIHJldHVybmVkOiB2b2lkIDAsXG4gICAgaGVhZGVyczogY29udGV4dD8uaGVhZGVycyxcbiAgICByZXF1ZXN0OiBjb250ZXh0Py5yZXF1ZXN0LFxuICAgIHBhcmFtczogXCJwYXJhbXNcIiBpbiBjb250ZXh0ID8gY29udGV4dC5wYXJhbXMgOiB2b2lkIDAsXG4gICAgbWV0aG9kOiBjb250ZXh0Lm1ldGhvZCxcbiAgICBzZXRIZWFkZXI6IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICBoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICB9LFxuICAgIGdldEhlYWRlcjogKGtleSkgPT4ge1xuICAgICAgaWYgKCFyZXF1ZXN0SGVhZGVycykgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gcmVxdWVzdEhlYWRlcnMuZ2V0KGtleSk7XG4gICAgfSxcbiAgICBnZXRDb29raWU6IChrZXksIHByZWZpeCkgPT4ge1xuICAgICAgY29uc3QgZmluYWxLZXkgPSBnZXRDb29raWVLZXkoa2V5LCBwcmVmaXgpO1xuICAgICAgaWYgKCFmaW5hbEtleSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWRDb29raWVzPy5nZXQoZmluYWxLZXkpIHx8IG51bGw7XG4gICAgfSxcbiAgICBnZXRTaWduZWRDb29raWU6IGFzeW5jIChrZXksIHNlY3JldCwgcHJlZml4KSA9PiB7XG4gICAgICBjb25zdCBmaW5hbEtleSA9IGdldENvb2tpZUtleShrZXksIHByZWZpeCk7XG4gICAgICBpZiAoIWZpbmFsS2V5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZWRDb29raWVzPy5nZXQoZmluYWxLZXkpO1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25hdHVyZVN0YXJ0UG9zID0gdmFsdWUubGFzdEluZGV4T2YoXCIuXCIpO1xuICAgICAgaWYgKHNpZ25hdHVyZVN0YXJ0UG9zIDwgMSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ25lZFZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNpZ25hdHVyZVN0YXJ0UG9zKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbHVlLnN1YnN0cmluZyhzaWduYXR1cmVTdGFydFBvcyArIDEpO1xuICAgICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDQ0IHx8ICFzaWduYXR1cmUuZW5kc1dpdGgoXCI9XCIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VjcmV0S2V5ID0gYXdhaXQgZ2V0Q3J5cHRvS2V5KHNlY3JldCk7XG4gICAgICBjb25zdCBpc1ZlcmlmaWVkID0gYXdhaXQgdmVyaWZ5U2lnbmF0dXJlKHNpZ25hdHVyZSwgc2lnbmVkVmFsdWUsIHNlY3JldEtleSk7XG4gICAgICByZXR1cm4gaXNWZXJpZmllZCA/IHNpZ25lZFZhbHVlIDogZmFsc2U7XG4gICAgfSxcbiAgICBzZXRDb29raWU6IChrZXksIHZhbHVlLCBvcHRpb25zMikgPT4ge1xuICAgICAgY29uc3QgY29va2llID0gc2VyaWFsaXplQ29va2llKGtleSwgdmFsdWUsIG9wdGlvbnMyKTtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwic2V0LWNvb2tpZVwiLCBjb29raWUpO1xuICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICB9LFxuICAgIHNldFNpZ25lZENvb2tpZTogYXN5bmMgKGtleSwgdmFsdWUsIHNlY3JldCwgb3B0aW9uczIpID0+IHtcbiAgICAgIGNvbnN0IGNvb2tpZSA9IGF3YWl0IHNlcmlhbGl6ZVNpZ25lZENvb2tpZShrZXksIHZhbHVlLCBzZWNyZXQsIG9wdGlvbnMyKTtcbiAgICAgIGhlYWRlcnMuYXBwZW5kKFwic2V0LWNvb2tpZVwiLCBjb29raWUpO1xuICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICB9LFxuICAgIHJlZGlyZWN0OiAodXJsKSA9PiB7XG4gICAgICBoZWFkZXJzLnNldChcImxvY2F0aW9uXCIsIHVybCk7XG4gICAgICByZXR1cm4gbmV3IEFQSUVycm9yKFwiRk9VTkRcIiwgdm9pZCAwLCBoZWFkZXJzKTtcbiAgICB9LFxuICAgIGVycm9yOiAoc3RhdHVzLCBib2R5LCBoZWFkZXJzMikgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBBUElFcnJvcihzdGF0dXMsIGJvZHksIGhlYWRlcnMyKTtcbiAgICB9LFxuICAgIGpzb246IChqc29uLCByb3V0ZXJSZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKCFjb250ZXh0LmFzUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBib2R5OiByb3V0ZXJSZXNwb25zZT8uYm9keSB8fCBqc29uLFxuICAgICAgICByb3V0ZXJSZXNwb25zZSxcbiAgICAgICAgX2ZsYWc6IFwianNvblwiXG4gICAgICB9O1xuICAgIH0sXG4gICAgcmVzcG9uc2VIZWFkZXJzOiBoZWFkZXJzXG4gIH07XG4gIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiBvcHRpb25zLnVzZSB8fCBbXSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWlkZGxld2FyZSh7XG4gICAgICAuLi5pbnRlcm5hbENvbnRleHQsXG4gICAgICByZXR1cm5IZWFkZXJzOiB0cnVlLFxuICAgICAgYXNSZXNwb25zZTogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2UucmVzcG9uc2UpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oaW50ZXJuYWxDb250ZXh0LmNvbnRleHQsIHJlc3BvbnNlLnJlc3BvbnNlKTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBpbnRlcm5hbENvbnRleHQucmVzcG9uc2VIZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW50ZXJuYWxDb250ZXh0O1xufTtcblxuLy8gc3JjL21pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmUob3B0aW9uc09ySGFuZGxlciwgaGFuZGxlcikge1xuICBjb25zdCBpbnRlcm5hbEhhbmRsZXIgPSBhc3luYyAoaW5wdXRDdHgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gaW5wdXRDdHg7XG4gICAgY29uc3QgX2hhbmRsZXIgPSB0eXBlb2Ygb3B0aW9uc09ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9uc09ySGFuZGxlciA6IGhhbmRsZXI7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgPyB7fSA6IG9wdGlvbnNPckhhbmRsZXI7XG4gICAgY29uc3QgaW50ZXJuYWxDb250ZXh0ID0gYXdhaXQgY3JlYXRlSW50ZXJuYWxDb250ZXh0KGNvbnRleHQsIHtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBwYXRoOiBcIi9cIlxuICAgIH0pO1xuICAgIGlmICghX2hhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImhhbmRsZXIgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9oYW5kbGVyKGludGVybmFsQ29udGV4dCk7XG4gICAgY29uc3QgaGVhZGVycyA9IGludGVybmFsQ29udGV4dC5yZXNwb25zZUhlYWRlcnM7XG4gICAgcmV0dXJuIGNvbnRleHQucmV0dXJuSGVhZGVycyA/IHtcbiAgICAgIGhlYWRlcnMsXG4gICAgICByZXNwb25zZVxuICAgIH0gOiByZXNwb25zZTtcbiAgfTtcbiAgaW50ZXJuYWxIYW5kbGVyLm9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiID8ge30gOiBvcHRpb25zT3JIYW5kbGVyO1xuICByZXR1cm4gaW50ZXJuYWxIYW5kbGVyO1xufVxuY3JlYXRlTWlkZGxld2FyZS5jcmVhdGUgPSAob3B0cykgPT4ge1xuICBmdW5jdGlvbiBmbihvcHRpb25zT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVNaWRkbGV3YXJlKFxuICAgICAgICB7XG4gICAgICAgICAgdXNlOiBvcHRzPy51c2VcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc09ySGFuZGxlclxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIGhhbmRsZXIgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG1pZGRsZXdhcmUgPSBjcmVhdGVNaWRkbGV3YXJlKFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zT3JIYW5kbGVyLFxuICAgICAgICBtZXRob2Q6IFwiKlwiLFxuICAgICAgICB1c2U6IFsuLi5vcHRzPy51c2UgfHwgW10sIC4uLm9wdGlvbnNPckhhbmRsZXIudXNlIHx8IFtdXVxuICAgICAgfSxcbiAgICAgIGhhbmRsZXJcbiAgICApO1xuICAgIHJldHVybiBtaWRkbGV3YXJlO1xuICB9XG4gIHJldHVybiBmbjtcbn07XG5cbi8vIHNyYy9lbmRwb2ludC50c1xudmFyIGNyZWF0ZUVuZHBvaW50MiA9IChwYXRoLCBvcHRpb25zLCBoYW5kbGVyKSA9PiB7XG4gIGNvbnN0IGludGVybmFsSGFuZGxlciA9IGFzeW5jICguLi5pbnB1dEN0eCkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSBpbnB1dEN0eFswXSB8fCB7fTtcbiAgICBjb25zdCBpbnRlcm5hbENvbnRleHQgPSBhd2FpdCBjcmVhdGVJbnRlcm5hbENvbnRleHQoY29udGV4dCwge1xuICAgICAgb3B0aW9ucyxcbiAgICAgIHBhdGhcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIoaW50ZXJuYWxDb250ZXh0KS5jYXRjaChhc3luYyAoZSkgPT4ge1xuICAgICAgaWYgKGlzQVBJRXJyb3IoZSkpIHtcbiAgICAgICAgY29uc3Qgb25BUElFcnJvciA9IG9wdGlvbnMub25BUElFcnJvcjtcbiAgICAgICAgaWYgKG9uQVBJRXJyb3IpIHtcbiAgICAgICAgICBhd2FpdCBvbkFQSUVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0LmFzUmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgICBjb25zdCBoZWFkZXJzID0gaW50ZXJuYWxDb250ZXh0LnJlc3BvbnNlSGVhZGVycztcbiAgICByZXR1cm4gY29udGV4dC5hc1Jlc3BvbnNlID8gdG9SZXNwb25zZShyZXNwb25zZSwge1xuICAgICAgaGVhZGVyc1xuICAgIH0pIDogY29udGV4dC5yZXR1cm5IZWFkZXJzID8ge1xuICAgICAgaGVhZGVycyxcbiAgICAgIHJlc3BvbnNlXG4gICAgfSA6IHJlc3BvbnNlO1xuICB9O1xuICBpbnRlcm5hbEhhbmRsZXIub3B0aW9ucyA9IG9wdGlvbnM7XG4gIGludGVybmFsSGFuZGxlci5wYXRoID0gcGF0aDtcbiAgcmV0dXJuIGludGVybmFsSGFuZGxlcjtcbn07XG5jcmVhdGVFbmRwb2ludDIuY3JlYXRlID0gKG9wdHMpID0+IHtcbiAgcmV0dXJuIChwYXRoLCBvcHRpb25zLCBoYW5kbGVyKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuZHBvaW50MihcbiAgICAgIHBhdGgsXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHVzZTogWy4uLm9wdGlvbnM/LnVzZSB8fCBbXSwgLi4ub3B0cz8udXNlIHx8IFtdXVxuICAgICAgfSxcbiAgICAgIGhhbmRsZXJcbiAgICApO1xuICB9O1xufTtcblxuLy8gc3JjL3JvdXRlci50c1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyIGFzIGNyZWF0ZVJvdTNSb3V0ZXIsIGFkZFJvdXRlLCBmaW5kUm91dGUsIGZpbmRBbGxSb3V0ZXMgfSBmcm9tIFwicm91M1wiO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9jb3JlLmpzXG52YXIgTkVWRVIgPSBPYmplY3QuZnJlZXplKHtcbiAgc3RhdHVzOiBcImFib3J0ZWRcIlxufSk7XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gJGNvbnN0cnVjdG9yKG5hbWUsIGluaXRpYWxpemVyMywgcGFyYW1zKSB7XG4gIGZ1bmN0aW9uIGluaXQoaW5zdCwgZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIl96b2RcIiwge1xuICAgICAgdmFsdWU6IGluc3QuX3pvZCA/PyB7fSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgKF9hID0gaW5zdC5fem9kKS50cmFpdHMgPz8gKF9hLnRyYWl0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIGluc3QuX3pvZC50cmFpdHMuYWRkKG5hbWUpO1xuICAgIGluaXRpYWxpemVyMyhpbnN0LCBkZWYpO1xuICAgIGZvciAoY29uc3QgayBpbiBfLnByb3RvdHlwZSkge1xuICAgICAgaWYgKCEoayBpbiBpbnN0KSlcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIGssIHsgdmFsdWU6IF8ucHJvdG90eXBlW2tdLmJpbmQoaW5zdCkgfSk7XG4gICAgfVxuICAgIGluc3QuX3pvZC5jb25zdHIgPSBfO1xuICAgIGluc3QuX3pvZC5kZWYgPSBkZWY7XG4gIH1cbiAgY29uc3QgUGFyZW50ID0gcGFyYW1zPy5QYXJlbnQgPz8gT2JqZWN0O1xuICBjbGFzcyBEZWZpbml0aW9uIGV4dGVuZHMgUGFyZW50IHtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmaW5pdGlvbiwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSk7XG4gIGZ1bmN0aW9uIF8oZGVmKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGluc3QgPSBwYXJhbXM/LlBhcmVudCA/IG5ldyBEZWZpbml0aW9uKCkgOiB0aGlzO1xuICAgIGluaXQoaW5zdCwgZGVmKTtcbiAgICAoX2EgPSBpbnN0Ll96b2QpLmRlZmVycmVkID8/IChfYS5kZWZlcnJlZCA9IFtdKTtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGluc3QuX3pvZC5kZWZlcnJlZCkge1xuICAgICAgZm4oKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIFwiaW5pdFwiLCB7IHZhbHVlOiBpbml0IH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXywgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IChpbnN0KSA9PiB7XG4gICAgICBpZiAocGFyYW1zPy5QYXJlbnQgJiYgaW5zdCBpbnN0YW5jZW9mIHBhcmFtcy5QYXJlbnQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGluc3Q/Ll96b2Q/LnRyYWl0cz8uaGFzKG5hbWUpO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBcIm5hbWVcIiwgeyB2YWx1ZTogbmFtZSB9KTtcbiAgcmV0dXJuIF87XG59XG52YXIgJGJyYW5kID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xudmFyICRab2RBc3luY0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKGBFbmNvdW50ZXJlZCBQcm9taXNlIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZS4gVXNlIC5wYXJzZUFzeW5jKCkgaW5zdGVhZC5gKTtcbiAgfVxufTtcbnZhciBnbG9iYWxDb25maWcgPSB7fTtcbmZ1bmN0aW9uIGNvbmZpZyhuZXdDb25maWcpIHtcbiAgaWYgKG5ld0NvbmZpZylcbiAgICBPYmplY3QuYXNzaWduKGdsb2JhbENvbmZpZywgbmV3Q29uZmlnKTtcbiAgcmV0dXJuIGdsb2JhbENvbmZpZztcbn1cblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvdXRpbC5qc1xudmFyIHV0aWxfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbF9leHBvcnRzLCB7XG4gIEJJR0lOVF9GT1JNQVRfUkFOR0VTOiAoKSA9PiBCSUdJTlRfRk9STUFUX1JBTkdFUyxcbiAgQ2xhc3M6ICgpID0+IENsYXNzLFxuICBOVU1CRVJfRk9STUFUX1JBTkdFUzogKCkgPT4gTlVNQkVSX0ZPUk1BVF9SQU5HRVMsXG4gIGFib3J0ZWQ6ICgpID0+IGFib3J0ZWQsXG4gIGFsbG93c0V2YWw6ICgpID0+IGFsbG93c0V2YWwsXG4gIGFzc2VydDogKCkgPT4gYXNzZXJ0LFxuICBhc3NlcnRFcXVhbDogKCkgPT4gYXNzZXJ0RXF1YWwsXG4gIGFzc2VydElzOiAoKSA9PiBhc3NlcnRJcyxcbiAgYXNzZXJ0TmV2ZXI6ICgpID0+IGFzc2VydE5ldmVyLFxuICBhc3NlcnROb3RFcXVhbDogKCkgPT4gYXNzZXJ0Tm90RXF1YWwsXG4gIGFzc2lnblByb3A6ICgpID0+IGFzc2lnblByb3AsXG4gIGNhY2hlZDogKCkgPT4gY2FjaGVkLFxuICBjYXB0dXJlU3RhY2tUcmFjZTogKCkgPT4gY2FwdHVyZVN0YWNrVHJhY2UsXG4gIGNsZWFuRW51bTogKCkgPT4gY2xlYW5FbnVtLFxuICBjbGVhblJlZ2V4OiAoKSA9PiBjbGVhblJlZ2V4LFxuICBjbG9uZTogKCkgPT4gY2xvbmUsXG4gIGNyZWF0ZVRyYW5zcGFyZW50UHJveHk6ICgpID0+IGNyZWF0ZVRyYW5zcGFyZW50UHJveHksXG4gIGRlZmluZUxhenk6ICgpID0+IGRlZmluZUxhenksXG4gIGVzYzogKCkgPT4gZXNjLFxuICBlc2NhcGVSZWdleDogKCkgPT4gZXNjYXBlUmVnZXgsXG4gIGV4dGVuZDogKCkgPT4gZXh0ZW5kLFxuICBmaW5hbGl6ZUlzc3VlOiAoKSA9PiBmaW5hbGl6ZUlzc3VlLFxuICBmbG9hdFNhZmVSZW1haW5kZXI6ICgpID0+IGZsb2F0U2FmZVJlbWFpbmRlcixcbiAgZ2V0RWxlbWVudEF0UGF0aDogKCkgPT4gZ2V0RWxlbWVudEF0UGF0aCxcbiAgZ2V0RW51bVZhbHVlczogKCkgPT4gZ2V0RW51bVZhbHVlcyxcbiAgZ2V0TGVuZ3RoYWJsZU9yaWdpbjogKCkgPT4gZ2V0TGVuZ3RoYWJsZU9yaWdpbixcbiAgZ2V0UGFyc2VkVHlwZTogKCkgPT4gZ2V0UGFyc2VkVHlwZSxcbiAgZ2V0U2l6YWJsZU9yaWdpbjogKCkgPT4gZ2V0U2l6YWJsZU9yaWdpbixcbiAgaXNPYmplY3Q6ICgpID0+IGlzT2JqZWN0LFxuICBpc1BsYWluT2JqZWN0OiAoKSA9PiBpc1BsYWluT2JqZWN0LFxuICBpc3N1ZTogKCkgPT4gaXNzdWUsXG4gIGpvaW5WYWx1ZXM6ICgpID0+IGpvaW5WYWx1ZXMsXG4gIGpzb25TdHJpbmdpZnlSZXBsYWNlcjogKCkgPT4ganNvblN0cmluZ2lmeVJlcGxhY2VyLFxuICBtZXJnZTogKCkgPT4gbWVyZ2UsXG4gIG5vcm1hbGl6ZVBhcmFtczogKCkgPT4gbm9ybWFsaXplUGFyYW1zLFxuICBudWxsaXNoOiAoKSA9PiBudWxsaXNoLFxuICBudW1LZXlzOiAoKSA9PiBudW1LZXlzLFxuICBvbWl0OiAoKSA9PiBvbWl0LFxuICBvcHRpb25hbEtleXM6ICgpID0+IG9wdGlvbmFsS2V5cyxcbiAgcGFydGlhbDogKCkgPT4gcGFydGlhbCxcbiAgcGljazogKCkgPT4gcGljayxcbiAgcHJlZml4SXNzdWVzOiAoKSA9PiBwcmVmaXhJc3N1ZXMsXG4gIHByaW1pdGl2ZVR5cGVzOiAoKSA9PiBwcmltaXRpdmVUeXBlcyxcbiAgcHJvbWlzZUFsbE9iamVjdDogKCkgPT4gcHJvbWlzZUFsbE9iamVjdCxcbiAgcHJvcGVydHlLZXlUeXBlczogKCkgPT4gcHJvcGVydHlLZXlUeXBlcyxcbiAgcmFuZG9tU3RyaW5nOiAoKSA9PiByYW5kb21TdHJpbmcsXG4gIHJlcXVpcmVkOiAoKSA9PiByZXF1aXJlZCxcbiAgc3RyaW5naWZ5UHJpbWl0aXZlOiAoKSA9PiBzdHJpbmdpZnlQcmltaXRpdmUsXG4gIHVud3JhcE1lc3NhZ2U6ICgpID0+IHVud3JhcE1lc3NhZ2Vcbn0pO1xuZnVuY3Rpb24gYXNzZXJ0RXF1YWwodmFsKSB7XG4gIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBhc3NlcnROb3RFcXVhbCh2YWwpIHtcbiAgcmV0dXJuIHZhbDtcbn1cbmZ1bmN0aW9uIGFzc2VydElzKF9hcmcpIHtcbn1cbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gIHRocm93IG5ldyBFcnJvcigpO1xufVxuZnVuY3Rpb24gYXNzZXJ0KF8pIHtcbn1cbmZ1bmN0aW9uIGdldEVudW1WYWx1ZXMoZW50cmllcykge1xuICBjb25zdCBudW1lcmljVmFsdWVzID0gT2JqZWN0LnZhbHVlcyhlbnRyaWVzKS5maWx0ZXIoKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiKTtcbiAgY29uc3QgdmFsdWVzID0gT2JqZWN0LmVudHJpZXMoZW50cmllcykuZmlsdGVyKChbaywgX10pID0+IG51bWVyaWNWYWx1ZXMuaW5kZXhPZigraykgPT09IC0xKS5tYXAoKFtfLCB2XSkgPT4gdik7XG4gIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5Miwgc2VwYXJhdG9yID0gXCJ8XCIpIHtcbiAgcmV0dXJuIGFycmF5Mi5tYXAoKHZhbCkgPT4gc3RyaW5naWZ5UHJpbWl0aXZlKHZhbCkpLmpvaW4oc2VwYXJhdG9yKTtcbn1cbmZ1bmN0aW9uIGpzb25TdHJpbmdpZnlSZXBsYWNlcihfLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKVxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjYWNoZWQoZ2V0dGVyKSB7XG4gIGNvbnN0IHNldCA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIGlmICghc2V0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHsgdmFsdWUgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhY2hlZCB2YWx1ZSBhbHJlYWR5IHNldFwiKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBudWxsaXNoKGlucHV0KSB7XG4gIHJldHVybiBpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gY2xlYW5SZWdleChzb3VyY2UpIHtcbiAgY29uc3Qgc3RhcnQgPSBzb3VyY2Uuc3RhcnRzV2l0aChcIl5cIikgPyAxIDogMDtcbiAgY29uc3QgZW5kID0gc291cmNlLmVuZHNXaXRoKFwiJFwiKSA/IHNvdXJjZS5sZW5ndGggLSAxIDogc291cmNlLmxlbmd0aDtcbiAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgZW5kKTtcbn1cbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgY29uc3Qgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gIGNvbnN0IHZhbEludCA9IE51bWJlci5wYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICBjb25zdCBzdGVwSW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICByZXR1cm4gdmFsSW50ICUgc3RlcEludCAvIDEwICoqIGRlY0NvdW50O1xufVxuZnVuY3Rpb24gZGVmaW5lTGF6eShvYmplY3QsIGtleSwgZ2V0dGVyKSB7XG4gIGNvbnN0IHNldCA9IGZhbHNlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICBnZXQoKSB7XG4gICAgICBpZiAoIXNldCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldHRlcigpO1xuICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWNoZWQgdmFsdWUgYWxyZWFkeSBzZXRcIik7XG4gICAgfSxcbiAgICBzZXQodikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2XG4gICAgICAgIC8vIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gYXNzaWduUHJvcCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIHtcbiAgICB2YWx1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRBdFBhdGgob2JqLCBwYXRoKSB7XG4gIGlmICghcGF0aClcbiAgICByZXR1cm4gb2JqO1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2M/LltrZXldLCBvYmopO1xufVxuZnVuY3Rpb24gcHJvbWlzZUFsbE9iamVjdChwcm9taXNlc09iaikge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvbWlzZXNPYmopO1xuICBjb25zdCBwcm9taXNlcyA9IGtleXMubWFwKChrZXkpID0+IHByb21pc2VzT2JqW2tleV0pO1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICBjb25zdCByZXNvbHZlZE9iaiA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzb2x2ZWRPYmpba2V5c1tpXV0gPSByZXN1bHRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWRPYmo7XG4gIH0pO1xufVxuZnVuY3Rpb24gcmFuZG9tU3RyaW5nKGxlbmd0aCA9IDEwKSB7XG4gIGNvbnN0IGNoYXJzID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuICBsZXQgc3RyID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHN0ciArPSBjaGFyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpXTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gZXNjKHN0cikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKTtcbn1cbnZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgOiAoLi4uX2FyZ3MpID0+IHtcbn07XG5mdW5jdGlvbiBpc09iamVjdChkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBkYXRhICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGRhdGEpO1xufVxudmFyIGFsbG93c0V2YWwgPSBjYWNoZWQoKCkgPT4ge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3I/LnVzZXJBZ2VudD8uaW5jbHVkZXMoXCJDbG91ZGZsYXJlXCIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgRiA9IEZ1bmN0aW9uO1xuICAgIG5ldyBGKFwiXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICBpZiAoaXNPYmplY3QobykgPT09IGZhbHNlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgY3RvciA9IG8uY29uc3RydWN0b3I7XG4gIGlmIChjdG9yID09PSB2b2lkIDApXG4gICAgcmV0dXJuIHRydWU7XG4gIGNvbnN0IHByb3QgPSBjdG9yLnByb3RvdHlwZTtcbiAgaWYgKGlzT2JqZWN0KHByb3QpID09PSBmYWxzZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdCwgXCJpc1Byb3RvdHlwZU9mXCIpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG51bUtleXMoZGF0YSkge1xuICBsZXQga2V5Q291bnQgPSAwO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpKSB7XG4gICAgICBrZXlDb3VudCsrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5Q291bnQ7XG59XG52YXIgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIE51bWJlci5pc05hTihkYXRhKSA/IFwibmFuXCIgOiBcIm51bWJlclwiO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBcImJpZ2ludFwiO1xuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgIHJldHVybiBcInN5bWJvbFwiO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS50aGVuICYmIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJiBkYXRhLmNhdGNoICYmIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIFwicHJvbWlzZVwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICByZXR1cm4gXCJtYXBcIjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIFwic2V0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIFwiZGF0ZVwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBGaWxlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIHJldHVybiBcImZpbGVcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke3R9YCk7XG4gIH1cbn07XG52YXIgcHJvcGVydHlLZXlUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcInN5bWJvbFwiXSk7XG52YXIgcHJpbWl0aXZlVHlwZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJiaWdpbnRcIiwgXCJib29sZWFuXCIsIFwic3ltYm9sXCIsIFwidW5kZWZpbmVkXCJdKTtcbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbmZ1bmN0aW9uIGNsb25lKGluc3QsIGRlZiwgcGFyYW1zKSB7XG4gIGNvbnN0IGNsID0gbmV3IGluc3QuX3pvZC5jb25zdHIoZGVmID8/IGluc3QuX3pvZC5kZWYpO1xuICBpZiAoIWRlZiB8fCBwYXJhbXM/LnBhcmVudClcbiAgICBjbC5fem9kLnBhcmVudCA9IGluc3Q7XG4gIHJldHVybiBjbDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKSB7XG4gIGNvbnN0IHBhcmFtcyA9IF9wYXJhbXM7XG4gIGlmICghcGFyYW1zKVxuICAgIHJldHVybiB7fTtcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHsgZXJyb3I6ICgpID0+IHBhcmFtcyB9O1xuICBpZiAocGFyYW1zPy5tZXNzYWdlICE9PSB2b2lkIDApIHtcbiAgICBpZiAocGFyYW1zPy5lcnJvciAhPT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNwZWNpZnkgYm90aCBgbWVzc2FnZWAgYW5kIGBlcnJvcmAgcGFyYW1zXCIpO1xuICAgIHBhcmFtcy5lcnJvciA9IHBhcmFtcy5tZXNzYWdlO1xuICB9XG4gIGRlbGV0ZSBwYXJhbXMubWVzc2FnZTtcbiAgaWYgKHR5cGVvZiBwYXJhbXMuZXJyb3IgPT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHsgLi4ucGFyYW1zLCBlcnJvcjogKCkgPT4gcGFyYW1zLmVycm9yIH07XG4gIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiBjcmVhdGVUcmFuc3BhcmVudFByb3h5KGdldHRlcikge1xuICBsZXQgdGFyZ2V0O1xuICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0KF8sIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICB9LFxuICAgIHNldChfLCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICB9LFxuICAgIGhhcyhfLCBwcm9wKSB7XG4gICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgIH0sXG4gICAgZGVsZXRlUHJvcGVydHkoXywgcHJvcCkge1xuICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuICAgIH0sXG4gICAgb3duS2V5cyhfKSB7XG4gICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihfLCBwcm9wKSB7XG4gICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApO1xuICAgIH0sXG4gICAgZGVmaW5lUHJvcGVydHkoXywgcHJvcCwgZGVzY3JpcHRvcikge1xuICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlQcmltaXRpdmUodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIilcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIFwiblwiO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgcmV0dXJuIGAke3ZhbHVlfWA7XG59XG5mdW5jdGlvbiBvcHRpb25hbEtleXMoc2hhcGUpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNoYXBlKS5maWx0ZXIoKGspID0+IHtcbiAgICByZXR1cm4gc2hhcGVba10uX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiICYmIHNoYXBlW2tdLl96b2Qub3B0b3V0ID09PSBcIm9wdGlvbmFsXCI7XG4gIH0pO1xufVxudmFyIE5VTUJFUl9GT1JNQVRfUkFOR0VTID0ge1xuICBzYWZlaW50OiBbTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXSxcbiAgaW50MzI6IFstMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0N10sXG4gIHVpbnQzMjogWzAsIDQyOTQ5NjcyOTVdLFxuICBmbG9hdDMyOiBbLTM0MDI4MjM0NjYzODUyODg2ZTIyLCAzNDAyODIzNDY2Mzg1Mjg4NmUyMl0sXG4gIGZsb2F0NjQ6IFstTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRV1cbn07XG52YXIgQklHSU5UX0ZPUk1BVF9SQU5HRVMgPSB7XG4gIGludDY0OiBbLyogQF9fUFVSRV9fICovIEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLCAvKiBAX19QVVJFX18gKi8gQmlnSW50KFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKV0sXG4gIHVpbnQ2NDogWy8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCksIC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoXCIxODQ0Njc0NDA3MzcwOTU1MTYxNVwiKV1cbn07XG5mdW5jdGlvbiBwaWNrKHNjaGVtYSwgbWFzaykge1xuICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICBjb25zdCBjdXJyRGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgaWYgKCEoa2V5IGluIGN1cnJEZWYuc2hhcGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICBjb250aW51ZTtcbiAgICBuZXdTaGFwZVtrZXldID0gY3VyckRlZi5zaGFwZVtrZXldO1xuICB9XG4gIHJldHVybiBjbG9uZShzY2hlbWEsIHtcbiAgICAuLi5zY2hlbWEuX3pvZC5kZWYsXG4gICAgc2hhcGU6IG5ld1NoYXBlLFxuICAgIGNoZWNrczogW11cbiAgfSk7XG59XG5mdW5jdGlvbiBvbWl0KHNjaGVtYSwgbWFzaykge1xuICBjb25zdCBuZXdTaGFwZSA9IHsgLi4uc2NoZW1hLl96b2QuZGVmLnNoYXBlIH07XG4gIGNvbnN0IGN1cnJEZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcbiAgICBpZiAoIShrZXkgaW4gY3VyckRlZi5zaGFwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgIH1cbiAgICBpZiAoIW1hc2tba2V5XSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGRlbGV0ZSBuZXdTaGFwZVtrZXldO1xuICB9XG4gIHJldHVybiBjbG9uZShzY2hlbWEsIHtcbiAgICAuLi5zY2hlbWEuX3pvZC5kZWYsXG4gICAgc2hhcGU6IG5ld1NoYXBlLFxuICAgIGNoZWNrczogW11cbiAgfSk7XG59XG5mdW5jdGlvbiBleHRlbmQoc2NoZW1hLCBzaGFwZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3Qoc2hhcGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0byBleHRlbmQ6IGV4cGVjdGVkIGEgcGxhaW4gb2JqZWN0XCIpO1xuICB9XG4gIGNvbnN0IGRlZiA9IHtcbiAgICAuLi5zY2hlbWEuX3pvZC5kZWYsXG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgY29uc3QgX3NoYXBlID0geyAuLi5zY2hlbWEuX3pvZC5kZWYuc2hhcGUsIC4uLnNoYXBlIH07XG4gICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgX3NoYXBlKTtcbiAgICAgIHJldHVybiBfc2hhcGU7XG4gICAgfSxcbiAgICBjaGVja3M6IFtdXG4gICAgLy8gZGVsZXRlIGV4aXN0aW5nIGNoZWNrc1xuICB9O1xuICByZXR1cm4gY2xvbmUoc2NoZW1hLCBkZWYpO1xufVxuZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICByZXR1cm4gY2xvbmUoYSwge1xuICAgIC4uLmEuX3pvZC5kZWYsXG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgY29uc3QgX3NoYXBlID0geyAuLi5hLl96b2QuZGVmLnNoYXBlLCAuLi5iLl96b2QuZGVmLnNoYXBlIH07XG4gICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgX3NoYXBlKTtcbiAgICAgIHJldHVybiBfc2hhcGU7XG4gICAgfSxcbiAgICBjYXRjaGFsbDogYi5fem9kLmRlZi5jYXRjaGFsbCxcbiAgICBjaGVja3M6IFtdXG4gICAgLy8gZGVsZXRlIGV4aXN0aW5nIGNoZWNrc1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWwoQ2xhc3MyLCBzY2hlbWEsIG1hc2spIHtcbiAgY29uc3Qgb2xkU2hhcGUgPSBzY2hlbWEuX3pvZC5kZWYuc2hhcGU7XG4gIGNvbnN0IHNoYXBlID0geyAuLi5vbGRTaGFwZSB9O1xuICBpZiAobWFzaykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcbiAgICAgIGlmICghKGtleSBpbiBvbGRTaGFwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQga2V5OiBcIiR7a2V5fVwiYCk7XG4gICAgICB9XG4gICAgICBpZiAoIW1hc2tba2V5XSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBzaGFwZVtrZXldID0gQ2xhc3MyID8gbmV3IENsYXNzMih7XG4gICAgICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldXG4gICAgICB9KSA6IG9sZFNoYXBlW2tleV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFNoYXBlKSB7XG4gICAgICBzaGFwZVtrZXldID0gQ2xhc3MyID8gbmV3IENsYXNzMih7XG4gICAgICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldXG4gICAgICB9KSA6IG9sZFNoYXBlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBjbG9uZShzY2hlbWEsIHtcbiAgICAuLi5zY2hlbWEuX3pvZC5kZWYsXG4gICAgc2hhcGUsXG4gICAgY2hlY2tzOiBbXVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlcXVpcmVkKENsYXNzMiwgc2NoZW1hLCBtYXNrKSB7XG4gIGNvbnN0IG9sZFNoYXBlID0gc2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuICBjb25zdCBzaGFwZSA9IHsgLi4ub2xkU2hhcGUgfTtcbiAgaWYgKG1hc2spIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgICBpZiAoIShrZXkgaW4gc2hhcGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgc2hhcGVba2V5XSA9IG5ldyBDbGFzczIoe1xuICAgICAgICB0eXBlOiBcIm5vbm9wdGlvbmFsXCIsXG4gICAgICAgIGlubmVyVHlwZTogb2xkU2hhcGVba2V5XVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFNoYXBlKSB7XG4gICAgICBzaGFwZVtrZXldID0gbmV3IENsYXNzMih7XG4gICAgICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lKHNjaGVtYSwge1xuICAgIC4uLnNjaGVtYS5fem9kLmRlZixcbiAgICBzaGFwZSxcbiAgICAvLyBvcHRpb25hbDogW10sXG4gICAgY2hlY2tzOiBbXVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFib3J0ZWQoeCwgc3RhcnRJbmRleCA9IDApIHtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCB4Lmlzc3Vlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh4Lmlzc3Vlc1tpXT8uY29udGludWUgIT09IHRydWUpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwcmVmaXhJc3N1ZXMocGF0aCwgaXNzdWVzKSB7XG4gIHJldHVybiBpc3N1ZXMubWFwKChpc3MpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gaXNzKS5wYXRoID8/IChfYS5wYXRoID0gW10pO1xuICAgIGlzcy5wYXRoLnVuc2hpZnQocGF0aCk7XG4gICAgcmV0dXJuIGlzcztcbiAgfSk7XG59XG5mdW5jdGlvbiB1bndyYXBNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2U/Lm1lc3NhZ2U7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcyKSB7XG4gIGNvbnN0IGZ1bGwgPSB7IC4uLmlzcywgcGF0aDogaXNzLnBhdGggPz8gW10gfTtcbiAgaWYgKCFpc3MubWVzc2FnZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB1bndyYXBNZXNzYWdlKGlzcy5pbnN0Py5fem9kLmRlZj8uZXJyb3I/Lihpc3MpKSA/PyB1bndyYXBNZXNzYWdlKGN0eD8uZXJyb3I/Lihpc3MpKSA/PyB1bndyYXBNZXNzYWdlKGNvbmZpZzIuY3VzdG9tRXJyb3I/Lihpc3MpKSA/PyB1bndyYXBNZXNzYWdlKGNvbmZpZzIubG9jYWxlRXJyb3I/Lihpc3MpKSA/PyBcIkludmFsaWQgaW5wdXRcIjtcbiAgICBmdWxsLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIGRlbGV0ZSBmdWxsLmluc3Q7XG4gIGRlbGV0ZSBmdWxsLmNvbnRpbnVlO1xuICBpZiAoIWN0eD8ucmVwb3J0SW5wdXQpIHtcbiAgICBkZWxldGUgZnVsbC5pbnB1dDtcbiAgfVxuICByZXR1cm4gZnVsbDtcbn1cbmZ1bmN0aW9uIGdldFNpemFibGVPcmlnaW4oaW5wdXQpIHtcbiAgaWYgKGlucHV0IGluc3RhbmNlb2YgU2V0KVxuICAgIHJldHVybiBcInNldFwiO1xuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBNYXApXG4gICAgcmV0dXJuIFwibWFwXCI7XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIEZpbGUpXG4gICAgcmV0dXJuIFwiZmlsZVwiO1xuICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5mdW5jdGlvbiBnZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSlcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5mdW5jdGlvbiBpc3N1ZSguLi5hcmdzKSB7XG4gIGNvbnN0IFtpc3MsIGlucHV0LCBpbnN0XSA9IGFyZ3M7XG4gIGlmICh0eXBlb2YgaXNzID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lc3NhZ2U6IGlzcyxcbiAgICAgIGNvZGU6IFwiY3VzdG9tXCIsXG4gICAgICBpbnB1dCxcbiAgICAgIGluc3RcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IC4uLmlzcyB9O1xufVxuZnVuY3Rpb24gY2xlYW5FbnVtKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKS5maWx0ZXIoKFtrLCBfXSkgPT4ge1xuICAgIHJldHVybiBOdW1iZXIuaXNOYU4oTnVtYmVyLnBhcnNlSW50KGssIDEwKSk7XG4gIH0pLm1hcCgoZWwpID0+IGVsWzFdKTtcbn1cbnZhciBDbGFzcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uX2FyZ3MpIHtcbiAgfVxufTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvZXJyb3JzLmpzXG52YXIgaW5pdGlhbGl6ZXIgPSAoaW5zdCwgZGVmKSA9PiB7XG4gIGluc3QubmFtZSA9IFwiJFpvZEVycm9yXCI7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIl96b2RcIiwge1xuICAgIHZhbHVlOiBpbnN0Ll96b2QsXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcImlzc3Vlc1wiLCB7XG4gICAgdmFsdWU6IGRlZixcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwibWVzc2FnZVwiLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRlZiwganNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAvLyBjb25maWd1cmFibGU6IGZhbHNlLFxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwidG9TdHJpbmdcIiwge1xuICAgIHZhbHVlOiAoKSA9PiBpbnN0Lm1lc3NhZ2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59O1xudmFyICRab2RFcnJvciA9ICRjb25zdHJ1Y3RvcihcIiRab2RFcnJvclwiLCBpbml0aWFsaXplcik7XG52YXIgJFpvZFJlYWxFcnJvciA9ICRjb25zdHJ1Y3RvcihcIiRab2RFcnJvclwiLCBpbml0aWFsaXplciwgeyBQYXJlbnQ6IEVycm9yIH0pO1xuZnVuY3Rpb24gZmxhdHRlbkVycm9yKGVycm9yLCBtYXBwZXIgPSAoaXNzdWUyKSA9PiBpc3N1ZTIubWVzc2FnZSkge1xuICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gIGZvciAoY29uc3Qgc3ViIG9mIGVycm9yLmlzc3Vlcykge1xuICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG59XG5mdW5jdGlvbiBmb3JtYXRFcnJvcihlcnJvciwgX21hcHBlcikge1xuICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8IGZ1bmN0aW9uKGlzc3VlMikge1xuICAgIHJldHVybiBpc3N1ZTIubWVzc2FnZTtcbiAgfTtcbiAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcjIpID0+IHtcbiAgICBmb3IgKGNvbnN0IGlzc3VlMiBvZiBlcnJvcjIuaXNzdWVzKSB7XG4gICAgICBpZiAoaXNzdWUyLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiICYmIGlzc3VlMi5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIGlzc3VlMi5lcnJvcnMubWFwKChpc3N1ZXMpID0+IHByb2Nlc3NFcnJvcih7IGlzc3VlcyB9KSk7XG4gICAgICB9IGVsc2UgaWYgKGlzc3VlMi5jb2RlID09PSBcImludmFsaWRfa2V5XCIpIHtcbiAgICAgICAgcHJvY2Vzc0Vycm9yKHsgaXNzdWVzOiBpc3N1ZTIuaXNzdWVzIH0pO1xuICAgICAgfSBlbHNlIGlmIChpc3N1ZTIuY29kZSA9PT0gXCJpbnZhbGlkX2VsZW1lbnRcIikge1xuICAgICAgICBwcm9jZXNzRXJyb3IoeyBpc3N1ZXM6IGlzc3VlMi5pc3N1ZXMgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzc3VlMi5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmaWVsZEVycm9ycy5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlMikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGlzc3VlMi5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUyLnBhdGhbaV07XG4gICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBpc3N1ZTIucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgIGN1cnJbZWxdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnIgPSBjdXJyW2VsXTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHByb2Nlc3NFcnJvcihlcnJvcik7XG4gIHJldHVybiBmaWVsZEVycm9ycztcbn1cblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvcGFyc2UuanNcbnZhciBfcGFyc2UgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgsIF9wYXJhbXMpID0+IHtcbiAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogZmFsc2UgfSkgOiB7IGFzeW5jOiBmYWxzZSB9O1xuICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oeyB2YWx1ZSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgIHRocm93IG5ldyAkWm9kQXN5bmNFcnJvcigpO1xuICB9XG4gIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgIGNvbnN0IGUgPSBuZXcgKF9wYXJhbXM/LkVyciA/PyBfRXJyKShyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpKTtcbiAgICBjYXB0dXJlU3RhY2tUcmFjZShlLCBfcGFyYW1zPy5jYWxsZWUpO1xuICAgIHRocm93IGU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn07XG52YXIgX3BhcnNlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgsIHBhcmFtcykgPT4ge1xuICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGFzeW5jOiB0cnVlIH0pIDogeyBhc3luYzogdHJ1ZSB9O1xuICBsZXQgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgcmVzdWx0ID0gYXdhaXQgcmVzdWx0O1xuICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBlID0gbmV3IChwYXJhbXM/LkVyciA/PyBfRXJyKShyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpKTtcbiAgICBjYXB0dXJlU3RhY2tUcmFjZShlLCBwYXJhbXM/LmNhbGxlZSk7XG4gICAgdGhyb3cgZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufTtcbnZhciBfc2FmZVBhcnNlID0gKF9FcnIpID0+IChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gIGNvbnN0IGN0eCA9IF9jdHggPyB7IC4uLl9jdHgsIGFzeW5jOiBmYWxzZSB9IDogeyBhc3luYzogZmFsc2UgfTtcbiAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICB0aHJvdyBuZXcgJFpvZEFzeW5jRXJyb3IoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0Lmlzc3Vlcy5sZW5ndGggPyB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgZXJyb3I6IG5ldyAoX0VyciA/PyAkWm9kRXJyb3IpKHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZygpKSkpXG4gIH0gOiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xufTtcbnZhciBzYWZlUGFyc2UgPSAvKiBAX19QVVJFX18gKi8gX3NhZmVQYXJzZSgkWm9kUmVhbEVycm9yKTtcbnZhciBfc2FmZVBhcnNlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogdHJ1ZSB9KSA6IHsgYXN5bmM6IHRydWUgfTtcbiAgbGV0IHJlc3VsdCA9IHNjaGVtYS5fem9kLnJ1bih7IHZhbHVlLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgIHJlc3VsdCA9IGF3YWl0IHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdC5pc3N1ZXMubGVuZ3RoID8ge1xuICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgIGVycm9yOiBuZXcgX0VycihyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpKVxuICB9IDogeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbn07XG52YXIgc2FmZVBhcnNlQXN5bmMgPSAvKiBAX19QVVJFX18gKi8gX3NhZmVQYXJzZUFzeW5jKCRab2RSZWFsRXJyb3IpO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9jaGVja3MuanNcbnZhciAkWm9kQ2hlY2sgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgdmFyIF9hO1xuICBpbnN0Ll96b2QgPz8gKGluc3QuX3pvZCA9IHt9KTtcbiAgaW5zdC5fem9kLmRlZiA9IGRlZjtcbiAgKF9hID0gaW5zdC5fem9kKS5vbmF0dGFjaCA/PyAoX2Eub25hdHRhY2ggPSBbXSk7XG59KTtcbnZhciAkWm9kQ2hlY2tNYXhMZW5ndGggPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWF4TGVuZ3RoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgdmFyIF9hO1xuICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgIHJldHVybiAhbnVsbGlzaCh2YWwpICYmIHZhbC5sZW5ndGggIT09IHZvaWQgMDtcbiAgfSk7XG4gIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0MikgPT4ge1xuICAgIGNvbnN0IGN1cnIgPSBpbnN0Mi5fem9kLmJhZy5tYXhpbXVtID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBpZiAoZGVmLm1heGltdW0gPCBjdXJyKVxuICAgICAgaW5zdDIuX3pvZC5iYWcubWF4aW11bSA9IGRlZi5tYXhpbXVtO1xuICB9KTtcbiAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPD0gZGVmLm1heGltdW0pXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qgb3JpZ2luID0gZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCk7XG4gICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICBvcmlnaW4sXG4gICAgICBjb2RlOiBcInRvb19iaWdcIixcbiAgICAgIG1heGltdW06IGRlZi5tYXhpbXVtLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgaW5wdXQsXG4gICAgICBpbnN0LFxuICAgICAgY29udGludWU6ICFkZWYuYWJvcnRcbiAgICB9KTtcbiAgfTtcbn0pO1xudmFyICRab2RDaGVja01pbkxlbmd0aCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tNaW5MZW5ndGhcIiwgKGluc3QsIGRlZikgPT4ge1xuICB2YXIgX2E7XG4gICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgcmV0dXJuICFudWxsaXNoKHZhbCkgJiYgdmFsLmxlbmd0aCAhPT0gdm9pZCAwO1xuICB9KTtcbiAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QyKSA9PiB7XG4gICAgY29uc3QgY3VyciA9IGluc3QyLl96b2QuYmFnLm1pbmltdW0gPz8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGlmIChkZWYubWluaW11bSA+IGN1cnIpXG4gICAgICBpbnN0Mi5fem9kLmJhZy5taW5pbXVtID0gZGVmLm1pbmltdW07XG4gIH0pO1xuICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+PSBkZWYubWluaW11bSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KTtcbiAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgIG9yaWdpbixcbiAgICAgIGNvZGU6IFwidG9vX3NtYWxsXCIsXG4gICAgICBtaW5pbXVtOiBkZWYubWluaW11bSxcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIGlucHV0LFxuICAgICAgaW5zdCxcbiAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0XG4gICAgfSk7XG4gIH07XG59KTtcbnZhciAkWm9kQ2hlY2tMZW5ndGhFcXVhbHMgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTGVuZ3RoRXF1YWxzXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgdmFyIF9hO1xuICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgIHJldHVybiAhbnVsbGlzaCh2YWwpICYmIHZhbC5sZW5ndGggIT09IHZvaWQgMDtcbiAgfSk7XG4gIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0MikgPT4ge1xuICAgIGNvbnN0IGJhZyA9IGluc3QyLl96b2QuYmFnO1xuICAgIGJhZy5taW5pbXVtID0gZGVmLmxlbmd0aDtcbiAgICBiYWcubWF4aW11bSA9IGRlZi5sZW5ndGg7XG4gICAgYmFnLmxlbmd0aCA9IGRlZi5sZW5ndGg7XG4gIH0pO1xuICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA9PT0gZGVmLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvcmlnaW4gPSBnZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KTtcbiAgICBjb25zdCB0b29CaWcgPSBsZW5ndGggPiBkZWYubGVuZ3RoO1xuICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgb3JpZ2luLFxuICAgICAgLi4udG9vQmlnID8geyBjb2RlOiBcInRvb19iaWdcIiwgbWF4aW11bTogZGVmLmxlbmd0aCB9IDogeyBjb2RlOiBcInRvb19zbWFsbFwiLCBtaW5pbXVtOiBkZWYubGVuZ3RoIH0sXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBleGFjdDogdHJ1ZSxcbiAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgaW5zdCxcbiAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0XG4gICAgfSk7XG4gIH07XG59KTtcbnZhciAkWm9kQ2hlY2tPdmVyd3JpdGUgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrT3ZlcndyaXRlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICBwYXlsb2FkLnZhbHVlID0gZGVmLnR4KHBheWxvYWQudmFsdWUpO1xuICB9O1xufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL2RvYy5qc1xudmFyIERvYyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoYXJncyA9IFtdKSB7XG4gICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgIGlmICh0aGlzKVxuICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuICBpbmRlbnRlZChmbikge1xuICAgIHRoaXMuaW5kZW50ICs9IDE7XG4gICAgZm4odGhpcyk7XG4gICAgdGhpcy5pbmRlbnQgLT0gMTtcbiAgfVxuICB3cml0ZShhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBhcmcodGhpcywgeyBleGVjdXRpb246IFwic3luY1wiIH0pO1xuICAgICAgYXJnKHRoaXMsIHsgZXhlY3V0aW9uOiBcImFzeW5jXCIgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSBhcmc7XG4gICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KFwiXFxuXCIpLmZpbHRlcigoeCkgPT4geCk7XG4gICAgY29uc3QgbWluSW5kZW50ID0gTWF0aC5taW4oLi4ubGluZXMubWFwKCh4KSA9PiB4Lmxlbmd0aCAtIHgudHJpbVN0YXJ0KCkubGVuZ3RoKSk7XG4gICAgY29uc3QgZGVkZW50ZWQgPSBsaW5lcy5tYXAoKHgpID0+IHguc2xpY2UobWluSW5kZW50KSkubWFwKCh4KSA9PiBcIiBcIi5yZXBlYXQodGhpcy5pbmRlbnQgKiAyKSArIHgpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiBkZWRlbnRlZCkge1xuICAgICAgdGhpcy5jb250ZW50LnB1c2gobGluZSk7XG4gICAgfVxuICB9XG4gIGNvbXBpbGUoKSB7XG4gICAgY29uc3QgRiA9IEZ1bmN0aW9uO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzPy5hcmdzO1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzPy5jb250ZW50ID8/IFtgYF07XG4gICAgY29uc3QgbGluZXMgPSBbLi4uY29udGVudC5tYXAoKHgpID0+IGAgICR7eH1gKV07XG4gICAgcmV0dXJuIG5ldyBGKC4uLmFyZ3MsIGxpbmVzLmpvaW4oXCJcXG5cIikpO1xuICB9XG59O1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS92ZXJzaW9ucy5qc1xudmFyIHZlcnNpb24gPSB7XG4gIG1ham9yOiA0LFxuICBtaW5vcjogMCxcbiAgcGF0Y2g6IDBcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3NjaGVtYXMuanNcbnZhciAkWm9kVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kVHlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gIHZhciBfYTtcbiAgaW5zdCA/PyAoaW5zdCA9IHt9KTtcbiAgaW5zdC5fem9kLmRlZiA9IGRlZjtcbiAgaW5zdC5fem9kLmJhZyA9IGluc3QuX3pvZC5iYWcgfHwge307XG4gIGluc3QuX3pvZC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgY29uc3QgY2hlY2tzID0gWy4uLmluc3QuX3pvZC5kZWYuY2hlY2tzID8/IFtdXTtcbiAgaWYgKGluc3QuX3pvZC50cmFpdHMuaGFzKFwiJFpvZENoZWNrXCIpKSB7XG4gICAgY2hlY2tzLnVuc2hpZnQoaW5zdCk7XG4gIH1cbiAgZm9yIChjb25zdCBjaCBvZiBjaGVja3MpIHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGNoLl96b2Qub25hdHRhY2gpIHtcbiAgICAgIGZuKGluc3QpO1xuICAgIH1cbiAgfVxuICBpZiAoY2hlY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgIChfYSA9IGluc3QuX3pvZCkuZGVmZXJyZWQgPz8gKF9hLmRlZmVycmVkID0gW10pO1xuICAgIGluc3QuX3pvZC5kZWZlcnJlZD8ucHVzaCgoKSA9PiB7XG4gICAgICBpbnN0Ll96b2QucnVuID0gaW5zdC5fem9kLnBhcnNlO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJ1bkNoZWNrcyA9IChwYXlsb2FkLCBjaGVja3MyLCBjdHgpID0+IHtcbiAgICAgIGxldCBpc0Fib3J0ZWQgPSBhYm9ydGVkKHBheWxvYWQpO1xuICAgICAgbGV0IGFzeW5jUmVzdWx0O1xuICAgICAgZm9yIChjb25zdCBjaCBvZiBjaGVja3MyKSB7XG4gICAgICAgIGlmIChjaC5fem9kLmRlZi53aGVuKSB7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkUnVuID0gY2guX3pvZC5kZWYud2hlbihwYXlsb2FkKTtcbiAgICAgICAgICBpZiAoIXNob3VsZFJ1bilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQWJvcnRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJMZW4gPSBwYXlsb2FkLmlzc3Vlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IF8gPSBjaC5fem9kLmNoZWNrKHBheWxvYWQpO1xuICAgICAgICBpZiAoXyBpbnN0YW5jZW9mIFByb21pc2UgJiYgY3R4Py5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgJFpvZEFzeW5jRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXN5bmNSZXN1bHQgfHwgXyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICBhc3luY1Jlc3VsdCA9IChhc3luY1Jlc3VsdCA/PyBQcm9taXNlLnJlc29sdmUoKSkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCBfO1xuICAgICAgICAgICAgY29uc3QgbmV4dExlbiA9IHBheWxvYWQuaXNzdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuZXh0TGVuID09PSBjdXJyTGVuKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWlzQWJvcnRlZClcbiAgICAgICAgICAgICAgaXNBYm9ydGVkID0gYWJvcnRlZChwYXlsb2FkLCBjdXJyTGVuKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXh0TGVuID0gcGF5bG9hZC5pc3N1ZXMubGVuZ3RoO1xuICAgICAgICAgIGlmIChuZXh0TGVuID09PSBjdXJyTGVuKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgaWYgKCFpc0Fib3J0ZWQpXG4gICAgICAgICAgICBpc0Fib3J0ZWQgPSBhYm9ydGVkKHBheWxvYWQsIGN1cnJMZW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXN5bmNSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGFzeW5jUmVzdWx0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG4gICAgaW5zdC5fem9kLnJ1biA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGluc3QuX3pvZC5wYXJzZShwYXlsb2FkLCBjdHgpO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgaWYgKGN0eC5hc3luYyA9PT0gZmFsc2UpXG4gICAgICAgICAgdGhyb3cgbmV3ICRab2RBc3luY0Vycm9yKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0MikgPT4gcnVuQ2hlY2tzKHJlc3VsdDIsIGNoZWNrcywgY3R4KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnVuQ2hlY2tzKHJlc3VsdCwgY2hlY2tzLCBjdHgpO1xuICAgIH07XG4gIH1cbiAgaW5zdFtcIn5zdGFuZGFyZFwiXSA9IHtcbiAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByID0gc2FmZVBhcnNlKGluc3QsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHIuc3VjY2VzcyA/IHsgdmFsdWU6IHIuZGF0YSB9IDogeyBpc3N1ZXM6IHIuZXJyb3I/Lmlzc3VlcyB9O1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gc2FmZVBhcnNlQXN5bmMoaW5zdCwgdmFsdWUpLnRoZW4oKHIpID0+IHIuc3VjY2VzcyA/IHsgdmFsdWU6IHIuZGF0YSB9IDogeyBpc3N1ZXM6IHIuZXJyb3I/Lmlzc3VlcyB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICB2ZXJzaW9uOiAxXG4gIH07XG59KTtcbnZhciAkWm9kVW5rbm93biA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kVW5rbm93blwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQpID0+IHBheWxvYWQ7XG59KTtcbnZhciAkWm9kTmV2ZXIgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZE5ldmVyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgZXhwZWN0ZWQ6IFwibmV2ZXJcIixcbiAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgIGluc3RcbiAgICB9KTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlQXJyYXlSZXN1bHQocmVzdWx0LCBmaW5hbCwgaW5kZXgpIHtcbiAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgZmluYWwuaXNzdWVzLnB1c2goLi4ucHJlZml4SXNzdWVzKGluZGV4LCByZXN1bHQuaXNzdWVzKSk7XG4gIH1cbiAgZmluYWwudmFsdWVbaW5kZXhdID0gcmVzdWx0LnZhbHVlO1xufVxudmFyICRab2RBcnJheSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQXJyYXlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgIGV4cGVjdGVkOiBcImFycmF5XCIsXG4gICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBpbnN0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBwYXlsb2FkLnZhbHVlID0gQXJyYXkoaW5wdXQubGVuZ3RoKTtcbiAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBpbnB1dFtpXTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5lbGVtZW50Ll96b2QucnVuKHtcbiAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgIGlzc3VlczogW11cbiAgICAgIH0sIGN0eCk7XG4gICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQyKSA9PiBoYW5kbGVBcnJheVJlc3VsdChyZXN1bHQyLCBwYXlsb2FkLCBpKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlQXJyYXlSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb21zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlT2JqZWN0UmVzdWx0KHJlc3VsdCwgZmluYWwsIGtleSkge1xuICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICBmaW5hbC5pc3N1ZXMucHVzaCguLi5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG4gIH1cbiAgZmluYWwudmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU9wdGlvbmFsT2JqZWN0UmVzdWx0KHJlc3VsdCwgZmluYWwsIGtleSwgaW5wdXQpIHtcbiAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGlucHV0W2tleV0gPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGtleSBpbiBpbnB1dCkge1xuICAgICAgICBmaW5hbC52YWx1ZVtrZXldID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWwudmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmluYWwuaXNzdWVzLnB1c2goLi4ucHJlZml4SXNzdWVzKGtleSwgcmVzdWx0Lmlzc3VlcykpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZXN1bHQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgIGlmIChrZXkgaW4gaW5wdXQpXG4gICAgICBmaW5hbC52YWx1ZVtrZXldID0gdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgIGZpbmFsLnZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gIH1cbn1cbnZhciAkWm9kT2JqZWN0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RPYmplY3RcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGNvbnN0IF9ub3JtYWxpemVkID0gY2FjaGVkKCgpID0+IHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGVmLnNoYXBlKTtcbiAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgaWYgKCEoZGVmLnNoYXBlW2tdIGluc3RhbmNlb2YgJFpvZFR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbGVtZW50IGF0IGtleSBcIiR7a31cIjogZXhwZWN0ZWQgYSBab2Qgc2NoZW1hYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9rZXlzID0gb3B0aW9uYWxLZXlzKGRlZi5zaGFwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNoYXBlOiBkZWYuc2hhcGUsXG4gICAgICBrZXlzLFxuICAgICAga2V5U2V0OiBuZXcgU2V0KGtleXMpLFxuICAgICAgbnVtS2V5czoga2V5cy5sZW5ndGgsXG4gICAgICBvcHRpb25hbEtleXM6IG5ldyBTZXQob2tleXMpXG4gICAgfTtcbiAgfSk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4ge1xuICAgIGNvbnN0IHNoYXBlID0gZGVmLnNoYXBlO1xuICAgIGNvbnN0IHByb3BWYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzaGFwZSkge1xuICAgICAgY29uc3QgZmllbGQgPSBzaGFwZVtrZXldLl96b2Q7XG4gICAgICBpZiAoZmllbGQudmFsdWVzKSB7XG4gICAgICAgIHByb3BWYWx1ZXNba2V5XSA/PyAocHJvcFZhbHVlc1trZXldID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBmaWVsZC52YWx1ZXMpXG4gICAgICAgICAgcHJvcFZhbHVlc1trZXldLmFkZCh2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZXM7XG4gIH0pO1xuICBjb25zdCBnZW5lcmF0ZUZhc3RwYXNzID0gKHNoYXBlKSA9PiB7XG4gICAgY29uc3QgZG9jID0gbmV3IERvYyhbXCJzaGFwZVwiLCBcInBheWxvYWRcIiwgXCJjdHhcIl0pO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBfbm9ybWFsaXplZC52YWx1ZTtcbiAgICBjb25zdCBwYXJzZVN0ciA9IChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGsgPSBlc2Moa2V5KTtcbiAgICAgIHJldHVybiBgc2hhcGVbJHtrfV0uX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXRbJHtrfV0sIGlzc3VlczogW10gfSwgY3R4KWA7XG4gICAgfTtcbiAgICBkb2Mud3JpdGUoYGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtgKTtcbiAgICBjb25zdCBpZHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygbm9ybWFsaXplZC5rZXlzKSB7XG4gICAgICBpZHNba2V5XSA9IGBrZXlfJHtjb3VudGVyKyt9YDtcbiAgICB9XG4gICAgZG9jLndyaXRlKGBjb25zdCBuZXdSZXN1bHQgPSB7fWApO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIG5vcm1hbGl6ZWQua2V5cykge1xuICAgICAgaWYgKG5vcm1hbGl6ZWQub3B0aW9uYWxLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnN0IGlkID0gaWRzW2tleV07XG4gICAgICAgIGRvYy53cml0ZShgY29uc3QgJHtpZH0gPSAke3BhcnNlU3RyKGtleSl9O2ApO1xuICAgICAgICBjb25zdCBrID0gZXNjKGtleSk7XG4gICAgICAgIGRvYy53cml0ZShgXG4gICAgICAgIGlmICgke2lkfS5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGlucHV0WyR7a31dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgke2t9IGluIGlucHV0KSB7XG4gICAgICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBwYXlsb2FkLmlzc3Vlcy5jb25jYXQoXG4gICAgICAgICAgICAgICR7aWR9Lmlzc3Vlcy5tYXAoKGlzcykgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5pc3MsXG4gICAgICAgICAgICAgICAgcGF0aDogaXNzLnBhdGggPyBbJHtrfSwgLi4uaXNzLnBhdGhdIDogWyR7a31dLFxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCR7aWR9LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoJHtrfSBpbiBpbnB1dCkgbmV3UmVzdWx0WyR7a31dID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9ICR7aWR9LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaWQgPSBpZHNba2V5XTtcbiAgICAgICAgZG9jLndyaXRlKGBjb25zdCAke2lkfSA9ICR7cGFyc2VTdHIoa2V5KX07YCk7XG4gICAgICAgIGRvYy53cml0ZShgXG4gICAgICAgICAgaWYgKCR7aWR9Lmlzc3Vlcy5sZW5ndGgpIHBheWxvYWQuaXNzdWVzID0gcGF5bG9hZC5pc3N1ZXMuY29uY2F0KCR7aWR9Lmlzc3Vlcy5tYXAoaXNzID0+ICh7XG4gICAgICAgICAgICAuLi5pc3MsXG4gICAgICAgICAgICBwYXRoOiBpc3MucGF0aCA/IFske2VzYyhrZXkpfSwgLi4uaXNzLnBhdGhdIDogWyR7ZXNjKGtleSl9XVxuICAgICAgICAgIH0pKSk7YCk7XG4gICAgICAgIGRvYy53cml0ZShgbmV3UmVzdWx0WyR7ZXNjKGtleSl9XSA9ICR7aWR9LnZhbHVlYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGRvYy53cml0ZShgcGF5bG9hZC52YWx1ZSA9IG5ld1Jlc3VsdDtgKTtcbiAgICBkb2Mud3JpdGUoYHJldHVybiBwYXlsb2FkO2ApO1xuICAgIGNvbnN0IGZuID0gZG9jLmNvbXBpbGUoKTtcbiAgICByZXR1cm4gKHBheWxvYWQsIGN0eCkgPT4gZm4oc2hhcGUsIHBheWxvYWQsIGN0eCk7XG4gIH07XG4gIGxldCBmYXN0cGFzcztcbiAgY29uc3QgaXNPYmplY3QyID0gaXNPYmplY3Q7XG4gIGNvbnN0IGppdCA9ICFnbG9iYWxDb25maWcuaml0bGVzcztcbiAgY29uc3QgYWxsb3dzRXZhbDIgPSBhbGxvd3NFdmFsO1xuICBjb25zdCBmYXN0RW5hYmxlZCA9IGppdCAmJiBhbGxvd3NFdmFsMi52YWx1ZTtcbiAgY29uc3QgY2F0Y2hhbGwgPSBkZWYuY2F0Y2hhbGw7XG4gIGxldCB2YWx1ZTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIHZhbHVlID8/ICh2YWx1ZSA9IF9ub3JtYWxpemVkLnZhbHVlKTtcbiAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgaWYgKCFpc09iamVjdDIoaW5wdXQpKSB7XG4gICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgZXhwZWN0ZWQ6IFwib2JqZWN0XCIsXG4gICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBpbnN0XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgIGlmIChqaXQgJiYgZmFzdEVuYWJsZWQgJiYgY3R4Py5hc3luYyA9PT0gZmFsc2UgJiYgY3R4LmppdGxlc3MgIT09IHRydWUpIHtcbiAgICAgIGlmICghZmFzdHBhc3MpXG4gICAgICAgIGZhc3RwYXNzID0gZ2VuZXJhdGVGYXN0cGFzcyhkZWYuc2hhcGUpO1xuICAgICAgcGF5bG9hZCA9IGZhc3RwYXNzKHBheWxvYWQsIGN0eCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBheWxvYWQudmFsdWUgPSB7fTtcbiAgICAgIGNvbnN0IHNoYXBlID0gdmFsdWUuc2hhcGU7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiB2YWx1ZS5rZXlzKSB7XG4gICAgICAgIGNvbnN0IGVsID0gc2hhcGVba2V5XTtcbiAgICAgICAgY29uc3QgciA9IGVsLl96b2QucnVuKHsgdmFsdWU6IGlucHV0W2tleV0sIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgY29uc3QgaXNPcHRpb25hbCA9IGVsLl96b2Qub3B0aW4gPT09IFwib3B0aW9uYWxcIiAmJiBlbC5fem9kLm9wdG91dCA9PT0gXCJvcHRpb25hbFwiO1xuICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICBwcm9tcy5wdXNoKHIudGhlbigocjIpID0+IGlzT3B0aW9uYWwgPyBoYW5kbGVPcHRpb25hbE9iamVjdFJlc3VsdChyMiwgcGF5bG9hZCwga2V5LCBpbnB1dCkgOiBoYW5kbGVPYmplY3RSZXN1bHQocjIsIHBheWxvYWQsIGtleSkpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICAgICAgaGFuZGxlT3B0aW9uYWxPYmplY3RSZXN1bHQociwgcGF5bG9hZCwga2V5LCBpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlT2JqZWN0UmVzdWx0KHIsIHBheWxvYWQsIGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjYXRjaGFsbCkge1xuICAgICAgcmV0dXJuIHByb21zLmxlbmd0aCA/IFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpIDogcGF5bG9hZDtcbiAgICB9XG4gICAgY29uc3QgdW5yZWNvZ25pemVkID0gW107XG4gICAgY29uc3Qga2V5U2V0ID0gdmFsdWUua2V5U2V0O1xuICAgIGNvbnN0IF9jYXRjaGFsbCA9IGNhdGNoYWxsLl96b2Q7XG4gICAgY29uc3QgdCA9IF9jYXRjaGFsbC5kZWYudHlwZTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbnB1dCkpIHtcbiAgICAgIGlmIChrZXlTZXQuaGFzKGtleSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKHQgPT09IFwibmV2ZXJcIikge1xuICAgICAgICB1bnJlY29nbml6ZWQucHVzaChrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHIgPSBfY2F0Y2hhbGwucnVuKHsgdmFsdWU6IGlucHV0W2tleV0sIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBwcm9tcy5wdXNoKHIudGhlbigocjIpID0+IGhhbmRsZU9iamVjdFJlc3VsdChyMiwgcGF5bG9hZCwga2V5KSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlT2JqZWN0UmVzdWx0KHIsIHBheWxvYWQsIGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1bnJlY29nbml6ZWQubGVuZ3RoKSB7XG4gICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgY29kZTogXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgICAgICBrZXlzOiB1bnJlY29nbml6ZWQsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBpbnN0XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFwcm9tcy5sZW5ndGgpXG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfSk7XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBmaW5hbCwgaW5zdCwgY3R4KSB7XG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGZpbmFsLnZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgcmV0dXJuIGZpbmFsO1xuICAgIH1cbiAgfVxuICBmaW5hbC5pc3N1ZXMucHVzaCh7XG4gICAgY29kZTogXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgaW5wdXQ6IGZpbmFsLnZhbHVlLFxuICAgIGluc3QsXG4gICAgZXJyb3JzOiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpKVxuICB9KTtcbiAgcmV0dXJuIGZpbmFsO1xufVxudmFyICRab2RVbmlvbiA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kVW5pb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5vcHRpb25zLnNvbWUoKG8pID0+IG8uX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiKSA/IFwib3B0aW9uYWxcIiA6IHZvaWQgMCk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYub3B0aW9ucy5zb21lKChvKSA9PiBvLl96b2Qub3B0b3V0ID09PSBcIm9wdGlvbmFsXCIpID8gXCJvcHRpb25hbFwiIDogdm9pZCAwKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IHtcbiAgICBpZiAoZGVmLm9wdGlvbnMuZXZlcnkoKG8pID0+IG8uX3pvZC52YWx1ZXMpKSB7XG4gICAgICByZXR1cm4gbmV3IFNldChkZWYub3B0aW9ucy5mbGF0TWFwKChvcHRpb24pID0+IEFycmF5LmZyb20ob3B0aW9uLl96b2QudmFsdWVzKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9KTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiB7XG4gICAgaWYgKGRlZi5vcHRpb25zLmV2ZXJ5KChvKSA9PiBvLl96b2QucGF0dGVybikpIHtcbiAgICAgIGNvbnN0IHBhdHRlcm5zID0gZGVmLm9wdGlvbnMubWFwKChvKSA9PiBvLl96b2QucGF0dGVybik7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXigke3BhdHRlcm5zLm1hcCgocCkgPT4gY2xlYW5SZWdleChwLnNvdXJjZSkpLmpvaW4oXCJ8XCIpfSkkYCk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH0pO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgbGV0IGFzeW5jID0gZmFsc2U7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGRlZi5vcHRpb25zKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3pvZC5ydW4oe1xuICAgICAgICB2YWx1ZTogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgfSwgY3R4KTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICBhc3luYyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghYXN5bmMpXG4gICAgICByZXR1cm4gaGFuZGxlVW5pb25SZXN1bHRzKHJlc3VsdHMsIHBheWxvYWQsIGluc3QsIGN0eCk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdHMpLnRoZW4oKHJlc3VsdHMyKSA9PiB7XG4gICAgICByZXR1cm4gaGFuZGxlVW5pb25SZXN1bHRzKHJlc3VsdHMyLCBwYXlsb2FkLCBpbnN0LCBjdHgpO1xuICAgIH0pO1xuICB9O1xufSk7XG52YXIgJFpvZEludGVyc2VjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kSW50ZXJzZWN0aW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgIGNvbnN0IGxlZnQgPSBkZWYubGVmdC5fem9kLnJ1bih7IHZhbHVlOiBpbnB1dCwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGVmLnJpZ2h0Ll96b2QucnVuKHsgdmFsdWU6IGlucHV0LCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgY29uc3QgYXN5bmMgPSBsZWZ0IGluc3RhbmNlb2YgUHJvbWlzZSB8fCByaWdodCBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2xlZnQsIHJpZ2h0XSkudGhlbigoW2xlZnQyLCByaWdodDJdKSA9PiB7XG4gICAgICAgIHJldHVybiBoYW5kbGVJbnRlcnNlY3Rpb25SZXN1bHRzKHBheWxvYWQsIGxlZnQyLCByaWdodDIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVJbnRlcnNlY3Rpb25SZXN1bHRzKHBheWxvYWQsIGxlZnQsIHJpZ2h0KTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gbWVyZ2VWYWx1ZXMoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gIH1cbiAgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlICYmICthID09PSArYikge1xuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gIH1cbiAgaWYgKGlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdChiKSkge1xuICAgIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gICAgY29uc3Qgc2hhcmVkS2V5cyA9IE9iamVjdC5rZXlzKGEpLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XG4gICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGFba2V5XSwgYltrZXldKTtcbiAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgbWVyZ2VFcnJvclBhdGg6IFtrZXksIC4uLnNoYXJlZFZhbHVlLm1lcmdlRXJyb3JQYXRoXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3T2JqIH07XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVyZ2VFcnJvclBhdGg6IFtdIH07XG4gICAgfVxuICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgbWVyZ2VFcnJvclBhdGg6IFtpbmRleCwgLi4uc2hhcmVkVmFsdWUubWVyZ2VFcnJvclBhdGhdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgfVxuICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lcmdlRXJyb3JQYXRoOiBbXSB9O1xufVxuZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0aW9uUmVzdWx0cyhyZXN1bHQsIGxlZnQsIHJpZ2h0KSB7XG4gIGlmIChsZWZ0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICByZXN1bHQuaXNzdWVzLnB1c2goLi4ubGVmdC5pc3N1ZXMpO1xuICB9XG4gIGlmIChyaWdodC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgcmVzdWx0Lmlzc3Vlcy5wdXNoKC4uLnJpZ2h0Lmlzc3Vlcyk7XG4gIH1cbiAgaWYgKGFib3J0ZWQocmVzdWx0KSlcbiAgICByZXR1cm4gcmVzdWx0O1xuICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhsZWZ0LnZhbHVlLCByaWdodC52YWx1ZSk7XG4gIGlmICghbWVyZ2VkLnZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbm1lcmdhYmxlIGludGVyc2VjdGlvbi4gRXJyb3IgcGF0aDogJHtKU09OLnN0cmluZ2lmeShtZXJnZWQubWVyZ2VFcnJvclBhdGgpfWApO1xuICB9XG4gIHJlc3VsdC52YWx1ZSA9IG1lcmdlZC5kYXRhO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyICRab2RFbnVtID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RFbnVtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBjb25zdCB2YWx1ZXMgPSBnZXRFbnVtVmFsdWVzKGRlZi5lbnRyaWVzKTtcbiAgaW5zdC5fem9kLnZhbHVlcyA9IG5ldyBTZXQodmFsdWVzKTtcbiAgaW5zdC5fem9kLnBhdHRlcm4gPSBuZXcgUmVnRXhwKGBeKCR7dmFsdWVzLmZpbHRlcigoaykgPT4gcHJvcGVydHlLZXlUeXBlcy5oYXModHlwZW9mIGspKS5tYXAoKG8pID0+IHR5cGVvZiBvID09PSBcInN0cmluZ1wiID8gZXNjYXBlUmVnZXgobykgOiBvLnRvU3RyaW5nKCkpLmpvaW4oXCJ8XCIpfSkkYCk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgIGlmIChpbnN0Ll96b2QudmFsdWVzLmhhcyhpbnB1dCkpIHtcbiAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgIGNvZGU6IFwiaW52YWxpZF92YWx1ZVwiLFxuICAgICAgdmFsdWVzLFxuICAgICAgaW5wdXQsXG4gICAgICBpbnN0XG4gICAgfSk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG59KTtcbnZhciAkWm9kVHJhbnNmb3JtID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RUcmFuc2Zvcm1cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgX291dCA9IGRlZi50cmFuc2Zvcm0ocGF5bG9hZC52YWx1ZSwgcGF5bG9hZCk7XG4gICAgaWYgKF9jdHguYXN5bmMpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IF9vdXQgaW5zdGFuY2VvZiBQcm9taXNlID8gX291dCA6IFByb21pc2UucmVzb2x2ZShfb3V0KTtcbiAgICAgIHJldHVybiBvdXRwdXQudGhlbigob3V0cHV0MikgPT4ge1xuICAgICAgICBwYXlsb2FkLnZhbHVlID0gb3V0cHV0MjtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKF9vdXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICB0aHJvdyBuZXcgJFpvZEFzeW5jRXJyb3IoKTtcbiAgICB9XG4gICAgcGF5bG9hZC52YWx1ZSA9IF9vdXQ7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG59KTtcbnZhciAkWm9kT3B0aW9uYWwgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZE9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gIGluc3QuX3pvZC5vcHRvdXQgPSBcIm9wdGlvbmFsXCI7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMgPyAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcywgdm9pZCAwXSkgOiB2b2lkIDA7XG4gIH0pO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IHtcbiAgICBjb25zdCBwYXR0ZXJuID0gZGVmLmlubmVyVHlwZS5fem9kLnBhdHRlcm47XG4gICAgcmV0dXJuIHBhdHRlcm4gPyBuZXcgUmVnRXhwKGBeKCR7Y2xlYW5SZWdleChwYXR0ZXJuLnNvdXJjZSl9KT8kYCkgOiB2b2lkIDA7XG4gIH0pO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgaWYgKGRlZi5pbm5lclR5cGUuX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiKSB7XG4gICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIH1cbiAgICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgfTtcbn0pO1xudmFyICRab2ROdWxsYWJsZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kTnVsbGFibGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRpbik7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0b3V0KTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiB7XG4gICAgY29uc3QgcGF0dGVybiA9IGRlZi5pbm5lclR5cGUuX3pvZC5wYXR0ZXJuO1xuICAgIHJldHVybiBwYXR0ZXJuID8gbmV3IFJlZ0V4cChgXigke2NsZWFuUmVnZXgocGF0dGVybi5zb3VyY2UpfXxudWxsKSRgKSA6IHZvaWQgMDtcbiAgfSk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMgPyAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcywgbnVsbF0pIDogdm9pZCAwO1xuICB9KTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSBudWxsKVxuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgfTtcbn0pO1xudmFyICRab2REZWZhdWx0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2REZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQyKSA9PiBoYW5kbGVEZWZhdWx0UmVzdWx0KHJlc3VsdDIsIGRlZikpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlRGVmYXVsdFJlc3VsdChyZXN1bHQsIGRlZik7XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZURlZmF1bHRSZXN1bHQocGF5bG9hZCwgZGVmKSB7XG4gIGlmIChwYXlsb2FkLnZhbHVlID09PSB2b2lkIDApIHtcbiAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmRlZmF1bHRWYWx1ZTtcbiAgfVxuICByZXR1cm4gcGF5bG9hZDtcbn1cbnZhciAkWm9kUHJlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFByZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICB9O1xufSk7XG52YXIgJFpvZE5vbk9wdGlvbmFsID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2ROb25PcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IHtcbiAgICBjb25zdCB2ID0gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcztcbiAgICByZXR1cm4gdiA/IG5ldyBTZXQoWy4uLnZdLmZpbHRlcigoeCkgPT4geCAhPT0gdm9pZCAwKSkgOiB2b2lkIDA7XG4gIH0pO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdDIpID0+IGhhbmRsZU5vbk9wdGlvbmFsUmVzdWx0KHJlc3VsdDIsIGluc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZU5vbk9wdGlvbmFsUmVzdWx0KHJlc3VsdCwgaW5zdCk7XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZU5vbk9wdGlvbmFsUmVzdWx0KHBheWxvYWQsIGluc3QpIHtcbiAgaWYgKCFwYXlsb2FkLmlzc3Vlcy5sZW5ndGggJiYgcGF5bG9hZC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgZXhwZWN0ZWQ6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgaW5zdFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXlsb2FkO1xufVxudmFyICRab2RDYXRjaCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ2F0Y2hcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRvdXQpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0MikgPT4ge1xuICAgICAgICBwYXlsb2FkLnZhbHVlID0gcmVzdWx0Mi52YWx1ZTtcbiAgICAgICAgaWYgKHJlc3VsdDIuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgaXNzdWVzOiByZXN1bHQyLmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwYXlsb2FkLnZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZygpKSlcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWVcbiAgICAgIH0pO1xuICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG59KTtcbnZhciAkWm9kUGlwZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kUGlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbi5fem9kLnZhbHVlcyk7XG4gIGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbi5fem9kLm9wdGluKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5vdXQuX3pvZC5vcHRvdXQpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgY29uc3QgbGVmdCA9IGRlZi5pbi5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGxlZnQudGhlbigobGVmdDIpID0+IGhhbmRsZVBpcGVSZXN1bHQobGVmdDIsIGRlZiwgY3R4KSk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVQaXBlUmVzdWx0KGxlZnQsIGRlZiwgY3R4KTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlUGlwZVJlc3VsdChsZWZ0LCBkZWYsIGN0eCkge1xuICBpZiAoYWJvcnRlZChsZWZ0KSkge1xuICAgIHJldHVybiBsZWZ0O1xuICB9XG4gIHJldHVybiBkZWYub3V0Ll96b2QucnVuKHsgdmFsdWU6IGxlZnQudmFsdWUsIGlzc3VlczogbGVmdC5pc3N1ZXMgfSwgY3R4KTtcbn1cbnZhciAkWm9kUmVhZG9ubHkgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFJlYWRvbmx5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwcm9wVmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5wcm9wVmFsdWVzKTtcbiAgZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMpO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0aW4pO1xuICBkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdG91dCk7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHJldHVybiByZXN1bHQudGhlbihoYW5kbGVSZWFkb25seVJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVSZWFkb25seVJlc3VsdChyZXN1bHQpO1xuICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVSZWFkb25seVJlc3VsdChwYXlsb2FkKSB7XG4gIHBheWxvYWQudmFsdWUgPSBPYmplY3QuZnJlZXplKHBheWxvYWQudmFsdWUpO1xuICByZXR1cm4gcGF5bG9hZDtcbn1cbnZhciAkWm9kQ3VzdG9tID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RDdXN0b21cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfKSA9PiB7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG4gIH07XG4gIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgIGNvbnN0IHIgPSBkZWYuZm4oaW5wdXQpO1xuICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHIudGhlbigocjIpID0+IGhhbmRsZVJlZmluZVJlc3VsdChyMiwgcGF5bG9hZCwgaW5wdXQsIGluc3QpKTtcbiAgICB9XG4gICAgaGFuZGxlUmVmaW5lUmVzdWx0KHIsIHBheWxvYWQsIGlucHV0LCBpbnN0KTtcbiAgICByZXR1cm47XG4gIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVJlZmluZVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGlucHV0LCBpbnN0KSB7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgY29uc3QgX2lzcyA9IHtcbiAgICAgIGNvZGU6IFwiY3VzdG9tXCIsXG4gICAgICBpbnB1dCxcbiAgICAgIGluc3QsXG4gICAgICAvLyBpbmNvcnBvcmF0ZXMgcGFyYW1zLmVycm9yIGludG8gaXNzdWUgcmVwb3J0aW5nXG4gICAgICBwYXRoOiBbLi4uaW5zdC5fem9kLmRlZi5wYXRoID8/IFtdXSxcbiAgICAgIC8vIGluY29ycG9yYXRlcyBwYXJhbXMuZXJyb3IgaW50byBpc3N1ZSByZXBvcnRpbmdcbiAgICAgIGNvbnRpbnVlOiAhaW5zdC5fem9kLmRlZi5hYm9ydFxuICAgICAgLy8gcGFyYW1zOiBpbnN0Ll96b2QuZGVmLnBhcmFtcyxcbiAgICB9O1xuICAgIGlmIChpbnN0Ll96b2QuZGVmLnBhcmFtcylcbiAgICAgIF9pc3MucGFyYW1zID0gaW5zdC5fem9kLmRlZi5wYXJhbXM7XG4gICAgcGF5bG9hZC5pc3N1ZXMucHVzaChpc3N1ZShfaXNzKSk7XG4gIH1cbn1cblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvcmVnaXN0cmllcy5qc1xudmFyICRvdXRwdXQgPSBTeW1ib2woXCJab2RPdXRwdXRcIik7XG52YXIgJGlucHV0ID0gU3ltYm9sKFwiWm9kSW5wdXRcIik7XG52YXIgJFpvZFJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9tYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2lkbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGQoc2NoZW1hLCAuLi5fbWV0YSkge1xuICAgIGNvbnN0IG1ldGEgPSBfbWV0YVswXTtcbiAgICB0aGlzLl9tYXAuc2V0KHNjaGVtYSwgbWV0YSk7XG4gICAgaWYgKG1ldGEgJiYgdHlwZW9mIG1ldGEgPT09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIG1ldGEpIHtcbiAgICAgIGlmICh0aGlzLl9pZG1hcC5oYXMobWV0YS5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJRCAke21ldGEuaWR9IGFscmVhZHkgZXhpc3RzIGluIHRoZSByZWdpc3RyeWApO1xuICAgICAgfVxuICAgICAgdGhpcy5faWRtYXAuc2V0KG1ldGEuaWQsIHNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5faWRtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlbW92ZShzY2hlbWEpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fbWFwLmdldChzY2hlbWEpO1xuICAgIGlmIChtZXRhICYmIHR5cGVvZiBtZXRhID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBtZXRhKSB7XG4gICAgICB0aGlzLl9pZG1hcC5kZWxldGUobWV0YS5pZCk7XG4gICAgfVxuICAgIHRoaXMuX21hcC5kZWxldGUoc2NoZW1hKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXQoc2NoZW1hKSB7XG4gICAgY29uc3QgcCA9IHNjaGVtYS5fem9kLnBhcmVudDtcbiAgICBpZiAocCkge1xuICAgICAgY29uc3QgcG0gPSB7IC4uLnRoaXMuZ2V0KHApID8/IHt9IH07XG4gICAgICBkZWxldGUgcG0uaWQ7XG4gICAgICByZXR1cm4geyAuLi5wbSwgLi4udGhpcy5fbWFwLmdldChzY2hlbWEpIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KHNjaGVtYSk7XG4gIH1cbiAgaGFzKHNjaGVtYSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHNjaGVtYSk7XG4gIH1cbn07XG5mdW5jdGlvbiByZWdpc3RyeSgpIHtcbiAgcmV0dXJuIG5ldyAkWm9kUmVnaXN0cnkoKTtcbn1cbnZhciBnbG9iYWxSZWdpc3RyeSA9IC8qIEBfX1BVUkVfXyAqLyByZWdpc3RyeSgpO1xuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9hcGkuanNcbmZ1bmN0aW9uIF91bmtub3duKENsYXNzMikge1xuICByZXR1cm4gbmV3IENsYXNzMih7XG4gICAgdHlwZTogXCJ1bmtub3duXCJcbiAgfSk7XG59XG5mdW5jdGlvbiBfbmV2ZXIoQ2xhc3MyLCBwYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyBDbGFzczIoe1xuICAgIHR5cGU6IFwibmV2ZXJcIixcbiAgICAuLi5ub3JtYWxpemVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9tYXhMZW5ndGgobWF4aW11bSwgcGFyYW1zKSB7XG4gIGNvbnN0IGNoID0gbmV3ICRab2RDaGVja01heExlbmd0aCh7XG4gICAgY2hlY2s6IFwibWF4X2xlbmd0aFwiLFxuICAgIC4uLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIG1heGltdW1cbiAgfSk7XG4gIHJldHVybiBjaDtcbn1cbmZ1bmN0aW9uIF9taW5MZW5ndGgobWluaW11bSwgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgJFpvZENoZWNrTWluTGVuZ3RoKHtcbiAgICBjaGVjazogXCJtaW5fbGVuZ3RoXCIsXG4gICAgLi4ubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgbWluaW11bVxuICB9KTtcbn1cbmZ1bmN0aW9uIF9sZW5ndGgobGVuZ3RoLCBwYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyAkWm9kQ2hlY2tMZW5ndGhFcXVhbHMoe1xuICAgIGNoZWNrOiBcImxlbmd0aF9lcXVhbHNcIixcbiAgICAuLi5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICBsZW5ndGhcbiAgfSk7XG59XG5mdW5jdGlvbiBfb3ZlcndyaXRlKHR4KSB7XG4gIHJldHVybiBuZXcgJFpvZENoZWNrT3ZlcndyaXRlKHtcbiAgICBjaGVjazogXCJvdmVyd3JpdGVcIixcbiAgICB0eFxuICB9KTtcbn1cbmZ1bmN0aW9uIF9hcnJheShDbGFzczIsIGVsZW1lbnQsIHBhcmFtcykge1xuICByZXR1cm4gbmV3IENsYXNzMih7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIGVsZW1lbnQsXG4gICAgLy8gZ2V0IGVsZW1lbnQoKSB7XG4gICAgLy8gICByZXR1cm4gZWxlbWVudDtcbiAgICAvLyB9LFxuICAgIC4uLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufVxuZnVuY3Rpb24gX3JlZmluZShDbGFzczIsIGZuLCBfcGFyYW1zKSB7XG4gIGNvbnN0IHNjaGVtYSA9IG5ldyBDbGFzczIoe1xuICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgY2hlY2s6IFwiY3VzdG9tXCIsXG4gICAgZm4sXG4gICAgLi4ubm9ybWFsaXplUGFyYW1zKF9wYXJhbXMpXG4gIH0pO1xuICByZXR1cm4gc2NoZW1hO1xufVxuXG4vLyBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9lcnJvcnMuanNcbnZhciBpbml0aWFsaXplcjIgPSAoaW5zdCwgaXNzdWVzKSA9PiB7XG4gICRab2RFcnJvci5pbml0KGluc3QsIGlzc3Vlcyk7XG4gIGluc3QubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW5zdCwge1xuICAgIGZvcm1hdDoge1xuICAgICAgdmFsdWU6IChtYXBwZXIpID0+IGZvcm1hdEVycm9yKGluc3QsIG1hcHBlcilcbiAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgZmxhdHRlbjoge1xuICAgICAgdmFsdWU6IChtYXBwZXIpID0+IGZsYXR0ZW5FcnJvcihpbnN0LCBtYXBwZXIpXG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGFkZElzc3VlOiB7XG4gICAgICB2YWx1ZTogKGlzc3VlMikgPT4gaW5zdC5pc3N1ZXMucHVzaChpc3N1ZTIpXG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGFkZElzc3Vlczoge1xuICAgICAgdmFsdWU6IChpc3N1ZXMyKSA9PiBpbnN0Lmlzc3Vlcy5wdXNoKC4uLmlzc3VlczIpXG4gICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGlzRW1wdHk6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgICAgIH1cbiAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH1cbiAgfSk7XG59O1xudmFyIFpvZEVycm9yID0gJGNvbnN0cnVjdG9yKFwiWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIyKTtcbnZhciBab2RSZWFsRXJyb3IgPSAkY29uc3RydWN0b3IoXCJab2RFcnJvclwiLCBpbml0aWFsaXplcjIsIHtcbiAgUGFyZW50OiBFcnJvclxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL3BhcnNlLmpzXG52YXIgcGFyc2UgPSAvKiBAX19QVVJFX18gKi8gX3BhcnNlKFpvZFJlYWxFcnJvcik7XG52YXIgcGFyc2VBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBfcGFyc2VBc3luYyhab2RSZWFsRXJyb3IpO1xudmFyIHNhZmVQYXJzZTIgPSAvKiBAX19QVVJFX18gKi8gX3NhZmVQYXJzZShab2RSZWFsRXJyb3IpO1xudmFyIHNhZmVQYXJzZUFzeW5jMiA9IC8qIEBfX1BVUkVfXyAqLyBfc2FmZVBhcnNlQXN5bmMoWm9kUmVhbEVycm9yKTtcblxuLy8gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NsYXNzaWMvc2NoZW1hcy5qc1xudmFyIFpvZFR5cGUgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kVHlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgaW5zdC5kZWYgPSBkZWY7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIl9kZWZcIiwgeyB2YWx1ZTogZGVmIH0pO1xuICBpbnN0LmNoZWNrID0gKC4uLmNoZWNrcykgPT4ge1xuICAgIHJldHVybiBpbnN0LmNsb25lKFxuICAgICAge1xuICAgICAgICAuLi5kZWYsXG4gICAgICAgIGNoZWNrczogW1xuICAgICAgICAgIC4uLmRlZi5jaGVja3MgPz8gW10sXG4gICAgICAgICAgLi4uY2hlY2tzLm1hcCgoY2gpID0+IHR5cGVvZiBjaCA9PT0gXCJmdW5jdGlvblwiID8geyBfem9kOiB7IGNoZWNrOiBjaCwgZGVmOiB7IGNoZWNrOiBcImN1c3RvbVwiIH0sIG9uYXR0YWNoOiBbXSB9IH0gOiBjaClcbiAgICAgICAgXVxuICAgICAgfVxuICAgICAgLy8geyBwYXJlbnQ6IHRydWUgfVxuICAgICk7XG4gIH07XG4gIGluc3QuY2xvbmUgPSAoZGVmMiwgcGFyYW1zKSA9PiBjbG9uZShpbnN0LCBkZWYyLCBwYXJhbXMpO1xuICBpbnN0LmJyYW5kID0gKCkgPT4gaW5zdDtcbiAgaW5zdC5yZWdpc3RlciA9IChyZWcsIG1ldGEpID0+IHtcbiAgICByZWcuYWRkKGluc3QsIG1ldGEpO1xuICAgIHJldHVybiBpbnN0O1xuICB9O1xuICBpbnN0LnBhcnNlID0gKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UoaW5zdCwgZGF0YSwgcGFyYW1zLCB7IGNhbGxlZTogaW5zdC5wYXJzZSB9KTtcbiAgaW5zdC5zYWZlUGFyc2UgPSAoZGF0YSwgcGFyYW1zKSA9PiBzYWZlUGFyc2UyKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gIGluc3QucGFyc2VBc3luYyA9IGFzeW5jIChkYXRhLCBwYXJhbXMpID0+IHBhcnNlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zLCB7IGNhbGxlZTogaW5zdC5wYXJzZUFzeW5jIH0pO1xuICBpbnN0LnNhZmVQYXJzZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gc2FmZVBhcnNlQXN5bmMyKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gIGluc3Quc3BhID0gaW5zdC5zYWZlUGFyc2VBc3luYztcbiAgaW5zdC5yZWZpbmUgPSAoY2hlY2syLCBwYXJhbXMpID0+IGluc3QuY2hlY2socmVmaW5lKGNoZWNrMiwgcGFyYW1zKSk7XG4gIGluc3Quc3VwZXJSZWZpbmUgPSAocmVmaW5lbWVudCkgPT4gaW5zdC5jaGVjayhzdXBlclJlZmluZShyZWZpbmVtZW50KSk7XG4gIGluc3Qub3ZlcndyaXRlID0gKGZuKSA9PiBpbnN0LmNoZWNrKF9vdmVyd3JpdGUoZm4pKTtcbiAgaW5zdC5vcHRpb25hbCA9ICgpID0+IG9wdGlvbmFsKGluc3QpO1xuICBpbnN0Lm51bGxhYmxlID0gKCkgPT4gbnVsbGFibGUoaW5zdCk7XG4gIGluc3QubnVsbGlzaCA9ICgpID0+IG9wdGlvbmFsKG51bGxhYmxlKGluc3QpKTtcbiAgaW5zdC5ub25vcHRpb25hbCA9IChwYXJhbXMpID0+IG5vbm9wdGlvbmFsKGluc3QsIHBhcmFtcyk7XG4gIGluc3QuYXJyYXkgPSAoKSA9PiBhcnJheShpbnN0KTtcbiAgaW5zdC5vciA9IChhcmcpID0+IHVuaW9uKFtpbnN0LCBhcmddKTtcbiAgaW5zdC5hbmQgPSAoYXJnKSA9PiBpbnRlcnNlY3Rpb24oaW5zdCwgYXJnKTtcbiAgaW5zdC50cmFuc2Zvcm0gPSAodHgpID0+IHBpcGUoaW5zdCwgdHJhbnNmb3JtKHR4KSk7XG4gIGluc3QuZGVmYXVsdCA9IChkZWYyKSA9PiBfZGVmYXVsdChpbnN0LCBkZWYyKTtcbiAgaW5zdC5wcmVmYXVsdCA9IChkZWYyKSA9PiBwcmVmYXVsdChpbnN0LCBkZWYyKTtcbiAgaW5zdC5jYXRjaCA9IChwYXJhbXMpID0+IF9jYXRjaChpbnN0LCBwYXJhbXMpO1xuICBpbnN0LnBpcGUgPSAodGFyZ2V0KSA9PiBwaXBlKGluc3QsIHRhcmdldCk7XG4gIGluc3QucmVhZG9ubHkgPSAoKSA9PiByZWFkb25seShpbnN0KTtcbiAgaW5zdC5kZXNjcmliZSA9IChkZXNjcmlwdGlvbikgPT4ge1xuICAgIGNvbnN0IGNsID0gaW5zdC5jbG9uZSgpO1xuICAgIGdsb2JhbFJlZ2lzdHJ5LmFkZChjbCwgeyBkZXNjcmlwdGlvbiB9KTtcbiAgICByZXR1cm4gY2w7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsUmVnaXN0cnkuZ2V0KGluc3QpPy5kZXNjcmlwdGlvbjtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgaW5zdC5tZXRhID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBnbG9iYWxSZWdpc3RyeS5nZXQoaW5zdCk7XG4gICAgfVxuICAgIGNvbnN0IGNsID0gaW5zdC5jbG9uZSgpO1xuICAgIGdsb2JhbFJlZ2lzdHJ5LmFkZChjbCwgYXJnc1swXSk7XG4gICAgcmV0dXJuIGNsO1xuICB9O1xuICBpbnN0LmlzT3B0aW9uYWwgPSAoKSA9PiBpbnN0LnNhZmVQYXJzZSh2b2lkIDApLnN1Y2Nlc3M7XG4gIGluc3QuaXNOdWxsYWJsZSA9ICgpID0+IGluc3Quc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gIHJldHVybiBpbnN0O1xufSk7XG52YXIgWm9kVW5rbm93biA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RVbmtub3duXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFVua25vd24uaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgcmV0dXJuIF91bmtub3duKFpvZFVua25vd24pO1xufVxudmFyIFpvZE5ldmVyID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZE5ldmVyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZE5ldmVyLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG59KTtcbmZ1bmN0aW9uIG5ldmVyKHBhcmFtcykge1xuICByZXR1cm4gX25ldmVyKFpvZE5ldmVyLCBwYXJhbXMpO1xufVxudmFyIFpvZEFycmF5ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZEFycmF5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZEFycmF5LmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuZWxlbWVudCA9IGRlZi5lbGVtZW50O1xuICBpbnN0Lm1pbiA9IChtaW5MZW5ndGgsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhfbWluTGVuZ3RoKG1pbkxlbmd0aCwgcGFyYW1zKSk7XG4gIGluc3Qubm9uZW1wdHkgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKF9taW5MZW5ndGgoMSwgcGFyYW1zKSk7XG4gIGluc3QubWF4ID0gKG1heExlbmd0aCwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKF9tYXhMZW5ndGgobWF4TGVuZ3RoLCBwYXJhbXMpKTtcbiAgaW5zdC5sZW5ndGggPSAobGVuLCBwYXJhbXMpID0+IGluc3QuY2hlY2soX2xlbmd0aChsZW4sIHBhcmFtcykpO1xuICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuZWxlbWVudDtcbn0pO1xuZnVuY3Rpb24gYXJyYXkoZWxlbWVudCwgcGFyYW1zKSB7XG4gIHJldHVybiBfYXJyYXkoWm9kQXJyYXksIGVsZW1lbnQsIHBhcmFtcyk7XG59XG52YXIgWm9kT2JqZWN0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZE9iamVjdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RPYmplY3QuaW5pdChpbnN0LCBkZWYpO1xuICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgdXRpbF9leHBvcnRzLmRlZmluZUxhenkoaW5zdCwgXCJzaGFwZVwiLCAoKSA9PiBkZWYuc2hhcGUpO1xuICBpbnN0LmtleW9mID0gKCkgPT4gX2VudW0oT2JqZWN0LmtleXMoaW5zdC5fem9kLmRlZi5zaGFwZSkpO1xuICBpbnN0LmNhdGNoYWxsID0gKGNhdGNoYWxsKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGwgfSk7XG4gIGluc3QucGFzc3Rocm91Z2ggPSAoKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGw6IHVua25vd24oKSB9KTtcbiAgaW5zdC5sb29zZSA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogdW5rbm93bigpIH0pO1xuICBpbnN0LnN0cmljdCA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogbmV2ZXIoKSB9KTtcbiAgaW5zdC5zdHJpcCA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogdm9pZCAwIH0pO1xuICBpbnN0LmV4dGVuZCA9IChpbmNvbWluZykgPT4ge1xuICAgIHJldHVybiB1dGlsX2V4cG9ydHMuZXh0ZW5kKGluc3QsIGluY29taW5nKTtcbiAgfTtcbiAgaW5zdC5tZXJnZSA9IChvdGhlcikgPT4gdXRpbF9leHBvcnRzLm1lcmdlKGluc3QsIG90aGVyKTtcbiAgaW5zdC5waWNrID0gKG1hc2spID0+IHV0aWxfZXhwb3J0cy5waWNrKGluc3QsIG1hc2spO1xuICBpbnN0Lm9taXQgPSAobWFzaykgPT4gdXRpbF9leHBvcnRzLm9taXQoaW5zdCwgbWFzayk7XG4gIGluc3QucGFydGlhbCA9ICguLi5hcmdzKSA9PiB1dGlsX2V4cG9ydHMucGFydGlhbChab2RPcHRpb25hbCwgaW5zdCwgYXJnc1swXSk7XG4gIGluc3QucmVxdWlyZWQgPSAoLi4uYXJncykgPT4gdXRpbF9leHBvcnRzLnJlcXVpcmVkKFpvZE5vbk9wdGlvbmFsLCBpbnN0LCBhcmdzWzBdKTtcbn0pO1xudmFyIFpvZFVuaW9uID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFVuaW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFVuaW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3Qub3B0aW9ucyA9IGRlZi5vcHRpb25zO1xufSk7XG5mdW5jdGlvbiB1bmlvbihvcHRpb25zLCBwYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIG9wdGlvbnMsXG4gICAgLi4udXRpbF9leHBvcnRzLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufVxudmFyIFpvZEludGVyc2VjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RJbnRlcnNlY3Rpb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kSW50ZXJzZWN0aW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG59KTtcbmZ1bmN0aW9uIGludGVyc2VjdGlvbihsZWZ0LCByaWdodCkge1xuICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgdHlwZTogXCJpbnRlcnNlY3Rpb25cIixcbiAgICBsZWZ0LFxuICAgIHJpZ2h0XG4gIH0pO1xufVxudmFyIFpvZEVudW0gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kRW51bVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RFbnVtLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QuZW51bSA9IGRlZi5lbnRyaWVzO1xuICBpbnN0Lm9wdGlvbnMgPSBPYmplY3QudmFsdWVzKGRlZi5lbnRyaWVzKTtcbiAgY29uc3Qga2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZGVmLmVudHJpZXMpKTtcbiAgaW5zdC5leHRyYWN0ID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgbmV3RW50cmllcyA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoa2V5cy5oYXModmFsdWUpKSB7XG4gICAgICAgIG5ld0VudHJpZXNbdmFsdWVdID0gZGVmLmVudHJpZXNbdmFsdWVdO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICR7dmFsdWV9IG5vdCBmb3VuZCBpbiBlbnVtYCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAuLi5kZWYsXG4gICAgICBjaGVja3M6IFtdLFxuICAgICAgLi4udXRpbF9leHBvcnRzLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgZW50cmllczogbmV3RW50cmllc1xuICAgIH0pO1xuICB9O1xuICBpbnN0LmV4Y2x1ZGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBuZXdFbnRyaWVzID0geyAuLi5kZWYuZW50cmllcyB9O1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICBpZiAoa2V5cy5oYXModmFsdWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuZXdFbnRyaWVzW3ZhbHVlXTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke3ZhbHVlfSBub3QgZm91bmQgaW4gZW51bWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgLi4uZGVmLFxuICAgICAgY2hlY2tzOiBbXSxcbiAgICAgIC4uLnV0aWxfZXhwb3J0cy5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgIGVudHJpZXM6IG5ld0VudHJpZXNcbiAgICB9KTtcbiAgfTtcbn0pO1xuZnVuY3Rpb24gX2VudW0odmFsdWVzLCBwYXJhbXMpIHtcbiAgY29uc3QgZW50cmllcyA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IE9iamVjdC5mcm9tRW50cmllcyh2YWx1ZXMubWFwKCh2KSA9PiBbdiwgdl0pKSA6IHZhbHVlcztcbiAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICBlbnRyaWVzLFxuICAgIC4uLnV0aWxfZXhwb3J0cy5ub3JtYWxpemVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn1cbnZhciBab2RUcmFuc2Zvcm0gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kVHJhbnNmb3JtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFRyYW5zZm9ybS5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgIHBheWxvYWQuYWRkSXNzdWUgPSAoaXNzdWUyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGlzc3VlMiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHV0aWxfZXhwb3J0cy5pc3N1ZShpc3N1ZTIsIHBheWxvYWQudmFsdWUsIGRlZikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgX2lzc3VlID0gaXNzdWUyO1xuICAgICAgICBpZiAoX2lzc3VlLmZhdGFsKVxuICAgICAgICAgIF9pc3N1ZS5jb250aW51ZSA9IGZhbHNlO1xuICAgICAgICBfaXNzdWUuY29kZSA/PyAoX2lzc3VlLmNvZGUgPSBcImN1c3RvbVwiKTtcbiAgICAgICAgX2lzc3VlLmlucHV0ID8/IChfaXNzdWUuaW5wdXQgPSBwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgX2lzc3VlLmluc3QgPz8gKF9pc3N1ZS5pbnN0ID0gaW5zdCk7XG4gICAgICAgIF9pc3N1ZS5jb250aW51ZSA/PyAoX2lzc3VlLmNvbnRpbnVlID0gdHJ1ZSk7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbF9leHBvcnRzLmlzc3VlKF9pc3N1ZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgb3V0cHV0ID0gZGVmLnRyYW5zZm9ybShwYXlsb2FkLnZhbHVlLCBwYXlsb2FkKTtcbiAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIG91dHB1dC50aGVuKChvdXRwdXQyKSA9PiB7XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBvdXRwdXQyO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBwYXlsb2FkLnZhbHVlID0gb3V0cHV0O1xuICAgIHJldHVybiBwYXlsb2FkO1xuICB9O1xufSk7XG5mdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgcmV0dXJuIG5ldyBab2RUcmFuc2Zvcm0oe1xuICAgIHR5cGU6IFwidHJhbnNmb3JtXCIsXG4gICAgdHJhbnNmb3JtOiBmblxuICB9KTtcbn1cbnZhciBab2RPcHRpb25hbCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RPcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2RPcHRpb25hbC5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5mdW5jdGlvbiBvcHRpb25hbChpbm5lclR5cGUpIHtcbiAgcmV0dXJuIG5ldyBab2RPcHRpb25hbCh7XG4gICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgIGlubmVyVHlwZVxuICB9KTtcbn1cbnZhciBab2ROdWxsYWJsZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2ROdWxsYWJsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICRab2ROdWxsYWJsZS5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5mdW5jdGlvbiBudWxsYWJsZShpbm5lclR5cGUpIHtcbiAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgdHlwZTogXCJudWxsYWJsZVwiLFxuICAgIGlubmVyVHlwZVxuICB9KTtcbn1cbnZhciBab2REZWZhdWx0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZERlZmF1bHRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kRGVmYXVsdC5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xuICBpbnN0LnJlbW92ZURlZmF1bHQgPSBpbnN0LnVud3JhcDtcbn0pO1xuZnVuY3Rpb24gX2RlZmF1bHQoaW5uZXJUeXBlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICB0eXBlOiBcImRlZmF1bHRcIixcbiAgICBpbm5lclR5cGUsXG4gICAgZ2V0IGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsdWUoKSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0pO1xufVxudmFyIFpvZFByZWZhdWx0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFByZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFByZWZhdWx0LmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmZ1bmN0aW9uIHByZWZhdWx0KGlubmVyVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiBuZXcgWm9kUHJlZmF1bHQoe1xuICAgIHR5cGU6IFwicHJlZmF1bHRcIixcbiAgICBpbm5lclR5cGUsXG4gICAgZ2V0IGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsdWUoKSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0pO1xufVxudmFyIFpvZE5vbk9wdGlvbmFsID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZE5vbk9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZE5vbk9wdGlvbmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmZ1bmN0aW9uIG5vbm9wdGlvbmFsKGlubmVyVHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgWm9kTm9uT3B0aW9uYWwoe1xuICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICBpbm5lclR5cGUsXG4gICAgLi4udXRpbF9leHBvcnRzLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufVxudmFyIFpvZENhdGNoID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZENhdGNoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZENhdGNoLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG4gIGluc3QucmVtb3ZlQ2F0Y2ggPSBpbnN0LnVud3JhcDtcbn0pO1xuZnVuY3Rpb24gX2NhdGNoKGlubmVyVHlwZSwgY2F0Y2hWYWx1ZSkge1xuICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICB0eXBlOiBcImNhdGNoXCIsXG4gICAgaW5uZXJUeXBlLFxuICAgIGNhdGNoVmFsdWU6IHR5cGVvZiBjYXRjaFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYXRjaFZhbHVlIDogKCkgPT4gY2F0Y2hWYWx1ZVxuICB9KTtcbn1cbnZhciBab2RQaXBlID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFBpcGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kUGlwZS5pbml0KGluc3QsIGRlZik7XG4gIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICBpbnN0LmluID0gZGVmLmluO1xuICBpbnN0Lm91dCA9IGRlZi5vdXQ7XG59KTtcbmZ1bmN0aW9uIHBpcGUoaW5fLCBvdXQpIHtcbiAgcmV0dXJuIG5ldyBab2RQaXBlKHtcbiAgICB0eXBlOiBcInBpcGVcIixcbiAgICBpbjogaW5fLFxuICAgIG91dFxuICAgIC8vIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gIH0pO1xufVxudmFyIFpvZFJlYWRvbmx5ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFJlYWRvbmx5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgJFpvZFJlYWRvbmx5LmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG59KTtcbmZ1bmN0aW9uIHJlYWRvbmx5KGlubmVyVHlwZSkge1xuICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICB0eXBlOiBcInJlYWRvbmx5XCIsXG4gICAgaW5uZXJUeXBlXG4gIH0pO1xufVxudmFyIFpvZEN1c3RvbSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RDdXN0b21cIiwgKGluc3QsIGRlZikgPT4ge1xuICAkWm9kQ3VzdG9tLmluaXQoaW5zdCwgZGVmKTtcbiAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG59KTtcbmZ1bmN0aW9uIGNoZWNrKGZuKSB7XG4gIGNvbnN0IGNoID0gbmV3ICRab2RDaGVjayh7XG4gICAgY2hlY2s6IFwiY3VzdG9tXCJcbiAgICAvLyAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICB9KTtcbiAgY2guX3pvZC5jaGVjayA9IGZuO1xuICByZXR1cm4gY2g7XG59XG5mdW5jdGlvbiByZWZpbmUoZm4sIF9wYXJhbXMgPSB7fSkge1xuICByZXR1cm4gX3JlZmluZShab2RDdXN0b20sIGZuLCBfcGFyYW1zKTtcbn1cbmZ1bmN0aW9uIHN1cGVyUmVmaW5lKGZuKSB7XG4gIGNvbnN0IGNoID0gY2hlY2soKHBheWxvYWQpID0+IHtcbiAgICBwYXlsb2FkLmFkZElzc3VlID0gKGlzc3VlMikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpc3N1ZTIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsX2V4cG9ydHMuaXNzdWUoaXNzdWUyLCBwYXlsb2FkLnZhbHVlLCBjaC5fem9kLmRlZikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgX2lzc3VlID0gaXNzdWUyO1xuICAgICAgICBpZiAoX2lzc3VlLmZhdGFsKVxuICAgICAgICAgIF9pc3N1ZS5jb250aW51ZSA9IGZhbHNlO1xuICAgICAgICBfaXNzdWUuY29kZSA/PyAoX2lzc3VlLmNvZGUgPSBcImN1c3RvbVwiKTtcbiAgICAgICAgX2lzc3VlLmlucHV0ID8/IChfaXNzdWUuaW5wdXQgPSBwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgX2lzc3VlLmluc3QgPz8gKF9pc3N1ZS5pbnN0ID0gY2gpO1xuICAgICAgICBfaXNzdWUuY29udGludWUgPz8gKF9pc3N1ZS5jb250aW51ZSA9ICFjaC5fem9kLmRlZi5hYm9ydCk7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbF9leHBvcnRzLmlzc3VlKF9pc3N1ZSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGZuKHBheWxvYWQudmFsdWUsIHBheWxvYWQpO1xuICB9KTtcbiAgcmV0dXJuIGNoO1xufVxuXG4vLyBzcmMvb3BlbmFwaS50c1xudmFyIHBhdGhzID0ge307XG5mdW5jdGlvbiBnZXRUeXBlRnJvbVpvZFR5cGUoem9kVHlwZSkge1xuICBzd2l0Y2ggKHpvZFR5cGUuY29uc3RydWN0b3IubmFtZSkge1xuICAgIGNhc2UgXCJab2RTdHJpbmdcIjpcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIGNhc2UgXCJab2ROdW1iZXJcIjpcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIGNhc2UgXCJab2RCb29sZWFuXCI6XG4gICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgY2FzZSBcIlpvZE9iamVjdFwiOlxuICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgY2FzZSBcIlpvZEFycmF5XCI6XG4gICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UGFyYW1ldGVycyhvcHRpb25zKSB7XG4gIGNvbnN0IHBhcmFtZXRlcnMgPSBbXTtcbiAgaWYgKG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LnBhcmFtZXRlcnMpIHtcbiAgICBwYXJhbWV0ZXJzLnB1c2goLi4ub3B0aW9ucy5tZXRhZGF0YS5vcGVuYXBpLnBhcmFtZXRlcnMpO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICB9XG4gIGlmIChvcHRpb25zLnF1ZXJ5IGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5xdWVyeS5zaGFwZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICAgICAgcGFyYW1ldGVycy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgaW46IFwicXVlcnlcIixcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IGdldFR5cGVGcm9tWm9kVHlwZSh2YWx1ZSksXG4gICAgICAgICAgICAuLi5cIm1pbkxlbmd0aFwiIGluIHZhbHVlICYmIHZhbHVlLm1pbkxlbmd0aCA/IHtcbiAgICAgICAgICAgICAgbWluTGVuZ3RoOiB2YWx1ZS5taW5MZW5ndGhcbiAgICAgICAgICAgIH0gOiB7fSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB2YWx1ZS5kZXNjcmlwdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG5mdW5jdGlvbiBnZXRSZXF1ZXN0Qm9keShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5yZXF1ZXN0Qm9keSkge1xuICAgIHJldHVybiBvcHRpb25zLm1ldGFkYXRhLm9wZW5hcGkucmVxdWVzdEJvZHk7XG4gIH1cbiAgaWYgKCFvcHRpb25zLmJvZHkpIHJldHVybiB2b2lkIDA7XG4gIGlmIChvcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBab2RPYmplY3QgfHwgb3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICBjb25zdCBzaGFwZSA9IG9wdGlvbnMuYm9keS5zaGFwZTtcbiAgICBpZiAoIXNoYXBlKSByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICBjb25zdCByZXF1aXJlZDIgPSBbXTtcbiAgICBPYmplY3QuZW50cmllcyhzaGFwZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICAgICAgcHJvcGVydGllc1trZXldID0ge1xuICAgICAgICAgIHR5cGU6IGdldFR5cGVGcm9tWm9kVHlwZSh2YWx1ZSksXG4gICAgICAgICAgZGVzY3JpcHRpb246IHZhbHVlLmRlc2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpKSB7XG4gICAgICAgICAgcmVxdWlyZWQyLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXF1aXJlZDogb3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgWm9kT3B0aW9uYWwgPyBmYWxzZSA6IG9wdGlvbnMuYm9keSA/IHRydWUgOiBmYWxzZSxcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHJlcXVpcmVkMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldFJlc3BvbnNlKHJlc3BvbnNlcykge1xuICByZXR1cm4ge1xuICAgIFwiNDAwXCI6IHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1aXJlZDogW1wibWVzc2FnZVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkJhZCBSZXF1ZXN0LiBVc3VhbGx5IGR1ZSB0byBtaXNzaW5nIHBhcmFtZXRlcnMsIG9yIGludmFsaWQgcGFyYW1ldGVycy5cIlxuICAgIH0sXG4gICAgXCI0MDFcIjoge1xuICAgICAgY29udGVudDoge1xuICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJtZXNzYWdlXCJdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IFwiVW5hdXRob3JpemVkLiBEdWUgdG8gbWlzc2luZyBvciBpbnZhbGlkIGF1dGhlbnRpY2F0aW9uLlwiXG4gICAgfSxcbiAgICBcIjQwM1wiOiB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IFwiRm9yYmlkZGVuLiBZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBhY2Nlc3MgdGhpcyByZXNvdXJjZSBvciB0byBwZXJmb3JtIHRoaXMgYWN0aW9uLlwiXG4gICAgfSxcbiAgICBcIjQwNFwiOiB7XG4gICAgICBjb250ZW50OiB7XG4gICAgICAgIFwiYXBwbGljYXRpb24vanNvblwiOiB7XG4gICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IFwiTm90IEZvdW5kLiBUaGUgcmVxdWVzdGVkIHJlc291cmNlIHdhcyBub3QgZm91bmQuXCJcbiAgICB9LFxuICAgIFwiNDI5XCI6IHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZXNjcmlwdGlvbjogXCJUb28gTWFueSBSZXF1ZXN0cy4gWW91IGhhdmUgZXhjZWVkZWQgdGhlIHJhdGUgbGltaXQuIFRyeSBhZ2FpbiBsYXRlci5cIlxuICAgIH0sXG4gICAgXCI1MDBcIjoge1xuICAgICAgY29udGVudDoge1xuICAgICAgICBcImFwcGxpY2F0aW9uL2pzb25cIjoge1xuICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkludGVybmFsIFNlcnZlciBFcnJvci4gVGhpcyBpcyBhIHByb2JsZW0gd2l0aCB0aGUgc2VydmVyIHRoYXQgeW91IGNhbm5vdCBmaXguXCJcbiAgICB9LFxuICAgIC4uLnJlc3BvbnNlc1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdG9yKGVuZHBvaW50cywgY29uZmlnMikge1xuICBjb25zdCBjb21wb25lbnRzID0ge1xuICAgIHNjaGVtYXM6IHt9XG4gIH07XG4gIE9iamVjdC5lbnRyaWVzKGVuZHBvaW50cykuZm9yRWFjaCgoW18sIHZhbHVlXSkgPT4ge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZS5vcHRpb25zO1xuICAgIGlmIChvcHRpb25zLm1ldGFkYXRhPy5TRVJWRVJfT05MWSkgcmV0dXJuO1xuICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gXCJHRVRcIikge1xuICAgICAgcGF0aHNbdmFsdWUucGF0aF0gPSB7XG4gICAgICAgIGdldDoge1xuICAgICAgICAgIHRhZ3M6IFtcIkRlZmF1bHRcIiwgLi4ub3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8udGFncyB8fCBbXV0sXG4gICAgICAgICAgZGVzY3JpcHRpb246IG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LmRlc2NyaXB0aW9uLFxuICAgICAgICAgIG9wZXJhdGlvbklkOiBvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5vcGVyYXRpb25JZCxcbiAgICAgICAgICBzZWN1cml0eTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBiZWFyZXJBdXRoOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgcGFyYW1ldGVyczogZ2V0UGFyYW1ldGVycyhvcHRpb25zKSxcbiAgICAgICAgICByZXNwb25zZXM6IGdldFJlc3BvbnNlKG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LnJlc3BvbnNlcylcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSBcIlBPU1RcIikge1xuICAgICAgY29uc3QgYm9keSA9IGdldFJlcXVlc3RCb2R5KG9wdGlvbnMpO1xuICAgICAgcGF0aHNbdmFsdWUucGF0aF0gPSB7XG4gICAgICAgIHBvc3Q6IHtcbiAgICAgICAgICB0YWdzOiBbXCJEZWZhdWx0XCIsIC4uLm9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LnRhZ3MgfHwgW11dLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5kZXNjcmlwdGlvbixcbiAgICAgICAgICBvcGVyYXRpb25JZDogb3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8ub3BlcmF0aW9uSWQsXG4gICAgICAgICAgc2VjdXJpdHk6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYmVhcmVyQXV0aDogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IGdldFBhcmFtZXRlcnMob3B0aW9ucyksXG4gICAgICAgICAgLi4uYm9keSA/IHsgcmVxdWVzdEJvZHk6IGJvZHkgfSA6IHtcbiAgICAgICAgICAgIHJlcXVlc3RCb2R5OiB7XG4gICAgICAgICAgICAgIC8vc2V0IGJvZHkgbm9uZVxuICAgICAgICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICAgICAgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHtcbiAgICAgICAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzcG9uc2VzOiBnZXRSZXNwb25zZShvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5yZXNwb25zZXMpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcmVzID0ge1xuICAgIG9wZW5hcGk6IFwiMy4xLjFcIixcbiAgICBpbmZvOiB7XG4gICAgICB0aXRsZTogXCJCZXR0ZXIgQXV0aFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQVBJIFJlZmVyZW5jZSBmb3IgeW91ciBCZXR0ZXIgQXV0aCBJbnN0YW5jZVwiLFxuICAgICAgdmVyc2lvbjogXCIxLjEuMFwiXG4gICAgfSxcbiAgICBjb21wb25lbnRzLFxuICAgIHNlY3VyaXR5OiBbXG4gICAgICB7XG4gICAgICAgIGFwaUtleUNvb2tpZTogW11cbiAgICAgIH1cbiAgICBdLFxuICAgIHNlcnZlcnM6IFtcbiAgICAgIHtcbiAgICAgICAgdXJsOiBjb25maWcyPy51cmxcbiAgICAgIH1cbiAgICBdLFxuICAgIHRhZ3M6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogXCJEZWZhdWx0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkRlZmF1bHQgZW5kcG9pbnRzIHRoYXQgYXJlIGluY2x1ZGVkIHdpdGggQmV0dGVyIEF1dGggYnkgZGVmYXVsdC4gVGhlc2UgZW5kcG9pbnRzIGFyZSBub3QgcGFydCBvZiBhbnkgcGx1Z2luLlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBwYXRoc1xuICB9O1xuICByZXR1cm4gcmVzO1xufVxudmFyIGdldEhUTUwgPSAoYXBpUmVmZXJlbmNlLCBjb25maWcyKSA9PiBgPCFkb2N0eXBlIGh0bWw+XG48aHRtbD5cbiAgPGhlYWQ+XG4gICAgPHRpdGxlPlNjYWxhciBBUEkgUmVmZXJlbmNlPC90aXRsZT5cbiAgICA8bWV0YSBjaGFyc2V0PVwidXRmLThcIiAvPlxuICAgIDxtZXRhXG4gICAgICBuYW1lPVwidmlld3BvcnRcIlxuICAgICAgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xXCIgLz5cbiAgPC9oZWFkPlxuICA8Ym9keT5cbiAgICA8c2NyaXB0XG4gICAgICBpZD1cImFwaS1yZWZlcmVuY2VcIlxuICAgICAgdHlwZT1cImFwcGxpY2F0aW9uL2pzb25cIj5cbiAgICAke0pTT04uc3RyaW5naWZ5KGFwaVJlZmVyZW5jZSl9XG4gICAgPC9zY3JpcHQ+XG5cdCA8c2NyaXB0PlxuICAgICAgdmFyIGNvbmZpZ3VyYXRpb24gPSB7XG5cdCAgXHRmYXZpY29uOiAke2NvbmZpZzI/LmxvZ28gPyBgZGF0YTppbWFnZS9zdmcreG1sO3V0ZjgsJHtlbmNvZGVVUklDb21wb25lbnQoY29uZmlnMi5sb2dvKX1gIDogdm9pZCAwfSAsXG5cdCAgIFx0dGhlbWU6ICR7Y29uZmlnMj8udGhlbWUgfHwgXCJzYXR1cm5cIn0sXG4gICAgICAgIG1ldGFEYXRhOiB7XG5cdFx0XHR0aXRsZTogJHtjb25maWcyPy50aXRsZSB8fCBcIk9wZW4gQVBJIFJlZmVyZW5jZVwifSxcblx0XHRcdGRlc2NyaXB0aW9uOiAke2NvbmZpZzI/LmRlc2NyaXB0aW9uIHx8IFwiQmV0dGVyIENhbGwgT3BlbiBBUElcIn0sXG5cdFx0fVxuICAgICAgfVxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwaS1yZWZlcmVuY2UnKS5kYXRhc2V0LmNvbmZpZ3VyYXRpb24gPVxuICAgICAgICBKU09OLnN0cmluZ2lmeShjb25maWd1cmF0aW9uKVxuICAgIDwvc2NyaXB0PlxuXHQgIDxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9Ac2NhbGFyL2FwaS1yZWZlcmVuY2VcIj48L3NjcmlwdD5cbiAgPC9ib2R5PlxuPC9odG1sPmA7XG5cbi8vIHNyYy9yb3V0ZXIudHNcbnZhciBjcmVhdGVSb3V0ZXIgPSAoZW5kcG9pbnRzLCBjb25maWcyKSA9PiB7XG4gIGlmICghY29uZmlnMj8ub3BlbmFwaT8uZGlzYWJsZWQpIHtcbiAgICBjb25zdCBvcGVuYXBpID0ge1xuICAgICAgcGF0aDogXCIvYXBpL3JlZmVyZW5jZVwiLFxuICAgICAgLi4uY29uZmlnMj8ub3BlbmFwaVxuICAgIH07XG4gICAgZW5kcG9pbnRzW1wib3BlbmFwaVwiXSA9IGNyZWF0ZUVuZHBvaW50MihcbiAgICAgIG9wZW5hcGkucGF0aCxcbiAgICAgIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiXG4gICAgICB9LFxuICAgICAgYXN5bmMgKGMpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gYXdhaXQgZ2VuZXJhdG9yKGVuZHBvaW50cyk7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoZ2V0SFRNTChzY2hlbWEsIG9wZW5hcGkuc2NhbGFyKSwge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9odG1sXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgY29uc3Qgcm91dGVyID0gY3JlYXRlUm91M1JvdXRlcigpO1xuICBjb25zdCBtaWRkbGV3YXJlUm91dGVyID0gY3JlYXRlUm91M1JvdXRlcigpO1xuICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIE9iamVjdC52YWx1ZXMoZW5kcG9pbnRzKSkge1xuICAgIGlmICghZW5kcG9pbnQub3B0aW9ucykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChlbmRwb2ludC5vcHRpb25zPy5tZXRhZGF0YT8uU0VSVkVSX09OTFkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IG1ldGhvZHMgPSBBcnJheS5pc0FycmF5KGVuZHBvaW50Lm9wdGlvbnM/Lm1ldGhvZCkgPyBlbmRwb2ludC5vcHRpb25zLm1ldGhvZCA6IFtlbmRwb2ludC5vcHRpb25zPy5tZXRob2RdO1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIG1ldGhvZHMpIHtcbiAgICAgIGFkZFJvdXRlKHJvdXRlciwgbWV0aG9kLCBlbmRwb2ludC5wYXRoLCBlbmRwb2ludCk7XG4gICAgfVxuICB9XG4gIGlmIChjb25maWcyPy5yb3V0ZXJNaWRkbGV3YXJlPy5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IHsgcGF0aCwgbWlkZGxld2FyZSB9IG9mIGNvbmZpZzIucm91dGVyTWlkZGxld2FyZSkge1xuICAgICAgYWRkUm91dGUobWlkZGxld2FyZVJvdXRlciwgXCIqXCIsIHBhdGgsIG1pZGRsZXdhcmUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwcm9jZXNzUmVxdWVzdCA9IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgY29uc3QgcGF0aCA9IGNvbmZpZzI/LmJhc2VQYXRoID8gdXJsLnBhdGhuYW1lLnNwbGl0KGNvbmZpZzIuYmFzZVBhdGgpLnJlZHVjZSgoYWNjLCBjdXJyLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgIGlmIChpbmRleCA+IDEpIHtcbiAgICAgICAgICBhY2MucHVzaChgJHtjb25maWcyLmJhc2VQYXRofSR7Y3Vycn1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2MucHVzaChjdXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSkuam9pbihcIlwiKSA6IHVybC5wYXRobmFtZTtcbiAgICBpZiAoIXBhdGg/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IHN0YXR1czogNDA0LCBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiIH0pO1xuICAgIH1cbiAgICBjb25zdCByb3V0ZSA9IGZpbmRSb3V0ZShyb3V0ZXIsIHJlcXVlc3QubWV0aG9kLCBwYXRoKTtcbiAgICBpZiAoIXJvdXRlPy5kYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHsgc3RhdHVzOiA0MDQsIHN0YXR1c1RleHQ6IFwiTm90IEZvdW5kXCIgfSk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5ID0ge307XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIHF1ZXJ5KSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5W2tleV0pKSB7XG4gICAgICAgICAgcXVlcnlba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV0sIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGhhbmRsZXIgPSByb3V0ZS5kYXRhO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBwYXRoLFxuICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgIHBhcmFtczogcm91dGUucGFyYW1zID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyb3V0ZS5wYXJhbXMpKSA6IHt9LFxuICAgICAgcmVxdWVzdCxcbiAgICAgIGJvZHk6IGhhbmRsZXIub3B0aW9ucy5kaXNhYmxlQm9keSA/IHZvaWQgMCA6IGF3YWl0IGdldEJvZHkoaGFuZGxlci5vcHRpb25zLmNsb25lUmVxdWVzdCA/IHJlcXVlc3QuY2xvbmUoKSA6IHJlcXVlc3QpLFxuICAgICAgcXVlcnksXG4gICAgICBfZmxhZzogXCJyb3V0ZXJcIixcbiAgICAgIGFzUmVzcG9uc2U6IHRydWUsXG4gICAgICBjb250ZXh0OiBjb25maWcyPy5yb3V0ZXJDb250ZXh0XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWlkZGxld2FyZVJvdXRlcyA9IGZpbmRBbGxSb3V0ZXMobWlkZGxld2FyZVJvdXRlciwgXCIqXCIsIHBhdGgpO1xuICAgICAgaWYgKG1pZGRsZXdhcmVSb3V0ZXM/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHsgZGF0YTogbWlkZGxld2FyZSwgcGFyYW1zIH0gb2YgbWlkZGxld2FyZVJvdXRlcykge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG1pZGRsZXdhcmUoe1xuICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIGFzUmVzcG9uc2U6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIoY29udGV4dCk7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChpc0FQSUVycm9yKGVycm9yKSkge1xuICAgICAgICByZXR1cm4gdG9SZXNwb25zZShlcnJvcik7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmVycm9yKGAjIFNFUlZFUl9FUlJPUjogYCwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICBzdGF0dXNUZXh0OiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgaGFuZGxlcjogYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICAgIGNvbnN0IG9uUmVxID0gYXdhaXQgY29uZmlnMj8ub25SZXF1ZXN0Py4ocmVxdWVzdCk7XG4gICAgICBpZiAob25SZXEgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gb25SZXE7XG4gICAgICB9XG4gICAgICBjb25zdCByZXEgPSBvblJlcSBpbnN0YW5jZW9mIFJlcXVlc3QgPyBvblJlcSA6IHJlcXVlc3Q7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBwcm9jZXNzUmVxdWVzdChyZXEpO1xuICAgICAgY29uc3Qgb25SZXMgPSBhd2FpdCBjb25maWcyPy5vblJlc3BvbnNlPy4ocmVzKTtcbiAgICAgIGlmIChvblJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBvblJlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBlbmRwb2ludHNcbiAgfTtcbn07XG5leHBvcnQge1xuICBBUElFcnJvcixcbiAgX3N0YXR1c0NvZGUsXG4gIGNyZWF0ZUVuZHBvaW50MiBhcyBjcmVhdGVFbmRwb2ludCxcbiAgY3JlYXRlSW50ZXJuYWxDb250ZXh0LFxuICBjcmVhdGVNaWRkbGV3YXJlLFxuICBjcmVhdGVSb3V0ZXIsXG4gIGdlbmVyYXRvcixcbiAgZ2V0Q29va2llS2V5LFxuICBnZXRIVE1MLFxuICBoaWRlSW50ZXJuYWxTdGFja0ZyYW1lcyxcbiAgbWFrZUVycm9yRm9ySGlkZVN0YWNrRnJhbWUsXG4gIHBhcnNlQ29va2llcyxcbiAgc2VyaWFsaXplQ29va2llLFxuICBzZXJpYWxpemVTaWduZWRDb29raWUsXG4gIHRvUmVzcG9uc2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/better-call/dist/index.js\n");

/***/ })

};
;